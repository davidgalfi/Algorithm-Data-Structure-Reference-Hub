{
  "data_structures": [
    {
      "id": 1,
      "name": "Array",
      "category": "Array",
      "description": "A collection of elements stored at contiguous memory locations",
      "time_complexity": {
        "access": "O(1)",
        "search": "O(n)",
        "insertion": "O(n)",
        "deletion": "O(n)"
      },
      "space_complexity": "O(n)",
      "use_cases": ["Random access to elements", "Mathematical operations", "Implementing other data structures"],
      "implementations": {
        "python": "# Python Array Implementation\nclass Array:\n    def __init__(self, capacity):\n        self.data = [None] * capacity\n        self.size = 0\n        self.capacity = capacity\n    \n    def get(self, index):\n        if 0 <= index < self.size:\n            return self.data[index]\n        raise IndexError('Index out of bounds')\n    \n    def set(self, index, value):\n        if 0 <= index < self.size:\n            self.data[index] = value\n        else:\n            raise IndexError('Index out of bounds')\n    \n    def append(self, value):\n        if self.size < self.capacity:\n            self.data[self.size] = value\n            self.size += 1\n        else:\n            raise OverflowError('Array is full')",
        "java": "// Java Array Implementation\npublic class Array<T> {\n    private Object[] data;\n    private int size;\n    private int capacity;\n    \n    public Array(int capacity) {\n        this.data = new Object[capacity];\n        this.size = 0;\n        this.capacity = capacity;\n    }\n    \n    @SuppressWarnings(\"unchecked\")\n    public T get(int index) {\n        if (index >= 0 && index < size) {\n            return (T) data[index];\n        }\n        throw new IndexOutOfBoundsException(\"Index out of bounds\");\n    }\n    \n    public void set(int index, T value) {\n        if (index >= 0 && index < size) {\n            data[index] = value;\n        } else {\n            throw new IndexOutOfBoundsException(\"Index out of bounds\");\n        }\n    }\n    \n    public void append(T value) {\n        if (size < capacity) {\n            data[size++] = value;\n        } else {\n            throw new RuntimeException(\"Array is full\");\n        }\n    }\n}",
        "csharp": "// C# Array Implementation\npublic class Array<T>\n{\n    private T[] data;\n    private int size;\n    private int capacity;\n    \n    public Array(int capacity)\n    {\n        this.data = new T[capacity];\n        this.size = 0;\n        this.capacity = capacity;\n    }\n    \n    public T Get(int index)\n    {\n        if (index >= 0 && index < size)\n        {\n            return data[index];\n        }\n        throw new IndexOutOfRangeException(\"Index out of bounds\");\n    }\n    \n    public void Set(int index, T value)\n    {\n        if (index >= 0 && index < size)\n        {\n            data[index] = value;\n        }\n        else\n        {\n            throw new IndexOutOfRangeException(\"Index out of bounds\");\n        }\n    }\n    \n    public void Append(T value)\n    {\n        if (size < capacity)\n        {\n            data[size++] = value;\n        }\n        else\n        {\n            throw new InvalidOperationException(\"Array is full\");\n        }\n    }\n}"
      }
    },
    {
      "id": 2,
      "name": "Linked List",
      "category": "Linked List",
      "description": "A linear data structure where elements are stored in nodes, each containing data and a reference to the next node",
      "time_complexity": {
        "access": "O(n)",
        "search": "O(n)",
        "insertion": "O(1)",
        "deletion": "O(1)"
      },
      "space_complexity": "O(n)",
      "use_cases": ["Dynamic memory allocation", "Implementing stacks and queues", "Undo functionality in applications"],
      "implementations": {
        "python": "# Python Linked List Implementation\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass LinkedList:\n    def __init__(self):\n        self.head = None\n        self.size = 0\n    \n    def append(self, val):\n        new_node = ListNode(val)\n        if not self.head:\n            self.head = new_node\n        else:\n            current = self.head\n            while current.next:\n                current = current.next\n            current.next = new_node\n        self.size += 1\n    \n    def prepend(self, val):\n        new_node = ListNode(val)\n        new_node.next = self.head\n        self.head = new_node\n        self.size += 1\n    \n    def delete(self, val):\n        if not self.head:\n            return\n        \n        if self.head.val == val:\n            self.head = self.head.next\n            self.size -= 1\n            return\n        \n        current = self.head\n        while current.next and current.next.val != val:\n            current = current.next\n        \n        if current.next:\n            current.next = current.next.next\n            self.size -= 1",
        "java": "// Java Linked List Implementation\nclass ListNode {\n    int val;\n    ListNode next;\n    \n    ListNode() {}\n    ListNode(int val) { this.val = val; }\n    ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n}\n\npublic class LinkedList {\n    private ListNode head;\n    private int size;\n    \n    public LinkedList() {\n        this.head = null;\n        this.size = 0;\n    }\n    \n    public void append(int val) {\n        ListNode newNode = new ListNode(val);\n        if (head == null) {\n            head = newNode;\n        } else {\n            ListNode current = head;\n            while (current.next != null) {\n                current = current.next;\n            }\n            current.next = newNode;\n        }\n        size++;\n    }\n    \n    public void prepend(int val) {\n        ListNode newNode = new ListNode(val);\n        newNode.next = head;\n        head = newNode;\n        size++;\n    }\n    \n    public void delete(int val) {\n        if (head == null) return;\n        \n        if (head.val == val) {\n            head = head.next;\n            size--;\n            return;\n        }\n        \n        ListNode current = head;\n        while (current.next != null && current.next.val != val) {\n            current = current.next;\n        }\n        \n        if (current.next != null) {\n            current.next = current.next.next;\n            size--;\n        }\n    }\n}",
        "csharp": "// C# Linked List Implementation\npublic class ListNode\n{\n    public int Val { get; set; }\n    public ListNode Next { get; set; }\n    \n    public ListNode(int val = 0, ListNode next = null)\n    {\n        Val = val;\n        Next = next;\n    }\n}\n\npublic class LinkedList\n{\n    private ListNode head;\n    private int size;\n    \n    public LinkedList()\n    {\n        head = null;\n        size = 0;\n    }\n    \n    public void Append(int val)\n    {\n        ListNode newNode = new ListNode(val);\n        if (head == null)\n        {\n            head = newNode;\n        }\n        else\n        {\n            ListNode current = head;\n            while (current.Next != null)\n            {\n                current = current.Next;\n            }\n            current.Next = newNode;\n        }\n        size++;\n    }\n    \n    public void Prepend(int val)\n    {\n        ListNode newNode = new ListNode(val);\n        newNode.Next = head;\n        head = newNode;\n        size++;\n    }\n    \n    public void Delete(int val)\n    {\n        if (head == null) return;\n        \n        if (head.Val == val)\n        {\n            head = head.Next;\n            size--;\n            return;\n        }\n        \n        ListNode current = head;\n        while (current.Next != null && current.Next.Val != val)\n        {\n            current = current.Next;\n        }\n        \n        if (current.Next != null)\n        {\n            current.Next = current.Next.Next;\n            size--;\n        }\n    }\n}"
      }
    },
    {
      "id": 3,
      "name": "Stack",
      "category": "Stack",
      "description": "A linear data structure that follows the Last In First Out (LIFO) principle",
      "time_complexity": {
        "access": "O(n)",
        "search": "O(n)",
        "insertion": "O(1)",
        "deletion": "O(1)"
      },
      "space_complexity": "O(n)",
      "use_cases": ["Function call management", "Expression evaluation", "Undo operations", "Browser history"],
      "implementations": {
        "python": "# Python Stack Implementation\nclass Stack:\n    def __init__(self):\n        self.items = []\n    \n    def push(self, item):\n        \"\"\"Add an item to the top of the stack\"\"\"\n        self.items.append(item)\n    \n    def pop(self):\n        \"\"\"Remove and return the top item from the stack\"\"\"\n        if self.is_empty():\n            raise IndexError(\"Stack is empty\")\n        return self.items.pop()\n    \n    def peek(self):\n        \"\"\"Return the top item without removing it\"\"\"\n        if self.is_empty():\n            raise IndexError(\"Stack is empty\")\n        return self.items[-1]\n    \n    def is_empty(self):\n        \"\"\"Check if the stack is empty\"\"\"\n        return len(self.items) == 0\n    \n    def size(self):\n        \"\"\"Return the number of items in the stack\"\"\"\n        return len(self.items)\n\n# Example usage\nstack = Stack()\nstack.push(1)\nstack.push(2)\nstack.push(3)\nprint(stack.pop())  # Output: 3\nprint(stack.peek()) # Output: 2",
        "java": "// Java Stack Implementation\nimport java.util.ArrayList;\nimport java.util.EmptyStackException;\n\npublic class Stack<T> {\n    private ArrayList<T> items;\n    \n    public Stack() {\n        items = new ArrayList<>();\n    }\n    \n    public void push(T item) {\n        items.add(item);\n    }\n    \n    public T pop() {\n        if (isEmpty()) {\n            throw new EmptyStackException();\n        }\n        return items.remove(items.size() - 1);\n    }\n    \n    public T peek() {\n        if (isEmpty()) {\n            throw new EmptyStackException();\n        }\n        return items.get(items.size() - 1);\n    }\n    \n    public boolean isEmpty() {\n        return items.isEmpty();\n    }\n    \n    public int size() {\n        return items.size();\n    }\n    \n    // Example usage\n    public static void main(String[] args) {\n        Stack<Integer> stack = new Stack<>();\n        stack.push(1);\n        stack.push(2);\n        stack.push(3);\n        System.out.println(stack.pop());  // Output: 3\n        System.out.println(stack.peek()); // Output: 2\n    }\n}",
        "csharp": "// C# Stack Implementation\nusing System;\nusing System.Collections.Generic;\n\npublic class Stack<T>\n{\n    private List<T> items;\n    \n    public Stack()\n    {\n        items = new List<T>();\n    }\n    \n    public void Push(T item)\n    {\n        items.Add(item);\n    }\n    \n    public T Pop()\n    {\n        if (IsEmpty())\n        {\n            throw new InvalidOperationException(\"Stack is empty\");\n        }\n        T item = items[items.Count - 1];\n        items.RemoveAt(items.Count - 1);\n        return item;\n    }\n    \n    public T Peek()\n    {\n        if (IsEmpty())\n        {\n            throw new InvalidOperationException(\"Stack is empty\");\n        }\n        return items[items.Count - 1];\n    }\n    \n    public bool IsEmpty()\n    {\n        return items.Count == 0;\n    }\n    \n    public int Size()\n    {\n        return items.Count;\n    }\n    \n    // Example usage\n    static void Main(string[] args)\n    {\n        Stack<int> stack = new Stack<int>();\n        stack.Push(1);\n        stack.Push(2);\n        stack.Push(3);\n        Console.WriteLine(stack.Pop());  // Output: 3\n        Console.WriteLine(stack.Peek()); // Output: 2\n    }\n}"
      }
    },
    {
      "id": 4,
      "name": "Queue",
      "category": "Queue",
      "description": "A linear data structure that follows the First In First Out (FIFO) principle",
      "time_complexity": {
        "access": "O(n)",
        "search": "O(n)",
        "insertion": "O(1)",
        "deletion": "O(1)"
      },
      "space_complexity": "O(n)",
      "use_cases": ["Process scheduling", "Breadth-first search", "Handling requests in web servers", "Print queue management"],
      "implementations": {
        "python": "# Python Queue Implementation\nfrom collections import deque\n\nclass Queue:\n    def __init__(self):\n        self.items = deque()\n    \n    def enqueue(self, item):\n        \"\"\"Add an item to the rear of the queue\"\"\"\n        self.items.append(item)\n    \n    def dequeue(self):\n        \"\"\"Remove and return the front item from the queue\"\"\"\n        if self.is_empty():\n            raise IndexError(\"Queue is empty\")\n        return self.items.popleft()\n    \n    def front(self):\n        \"\"\"Return the front item without removing it\"\"\"\n        if self.is_empty():\n            raise IndexError(\"Queue is empty\")\n        return self.items[0]\n    \n    def is_empty(self):\n        \"\"\"Check if the queue is empty\"\"\"\n        return len(self.items) == 0\n    \n    def size(self):\n        \"\"\"Return the number of items in the queue\"\"\"\n        return len(self.items)\n\n# Example usage\nqueue = Queue()\nqueue.enqueue(1)\nqueue.enqueue(2)\nqueue.enqueue(3)\nprint(queue.dequeue())  # Output: 1\nprint(queue.front())    # Output: 2",
        "java": "// Java Queue Implementation\nimport java.util.LinkedList;\nimport java.util.NoSuchElementException;\n\npublic class Queue<T> {\n    private LinkedList<T> items;\n    \n    public Queue() {\n        items = new LinkedList<>();\n    }\n    \n    public void enqueue(T item) {\n        items.addLast(item);\n    }\n    \n    public T dequeue() {\n        if (isEmpty()) {\n            throw new NoSuchElementException(\"Queue is empty\");\n        }\n        return items.removeFirst();\n    }\n    \n    public T front() {\n        if (isEmpty()) {\n            throw new NoSuchElementException(\"Queue is empty\");\n        }\n        return items.getFirst();\n    }\n    \n    public boolean isEmpty() {\n        return items.isEmpty();\n    }\n    \n    public int size() {\n        return items.size();\n    }\n    \n    // Example usage\n    public static void main(String[] args) {\n        Queue<Integer> queue = new Queue<>();\n        queue.enqueue(1);\n        queue.enqueue(2);\n        queue.enqueue(3);\n        System.out.println(queue.dequeue());  // Output: 1\n        System.out.println(queue.front());    // Output: 2\n    }\n}",
        "csharp": "// C# Queue Implementation\nusing System;\nusing System.Collections.Generic;\n\npublic class Queue<T>\n{\n    private LinkedList<T> items;\n    \n    public Queue()\n    {\n        items = new LinkedList<T>();\n    }\n    \n    public void Enqueue(T item)\n    {\n        items.AddLast(item);\n    }\n    \n    public T Dequeue()\n    {\n        if (IsEmpty())\n        {\n            throw new InvalidOperationException(\"Queue is empty\");\n        }\n        T item = items.First.Value;\n        items.RemoveFirst();\n        return item;\n    }\n    \n    public T Front()\n    {\n        if (IsEmpty())\n        {\n            throw new InvalidOperationException(\"Queue is empty\");\n        }\n        return items.First.Value;\n    }\n    \n    public bool IsEmpty()\n    {\n        return items.Count == 0;\n    }\n    \n    public int Size()\n    {\n        return items.Count;\n    }\n    \n    // Example usage\n    static void Main(string[] args)\n    {\n        Queue<int> queue = new Queue<int>();\n        queue.Enqueue(1);\n        queue.Enqueue(2);\n        queue.Enqueue(3);\n        Console.WriteLine(queue.Dequeue());  // Output: 1\n        Console.WriteLine(queue.Front());    // Output: 2\n    }\n}"
      }
    },
    {
      "id": 5,
      "name": "Hash Table",
      "category": "Hash Table",
      "description": "A data structure that implements an associative array abstract data type, using a hash function to compute an index",
      "time_complexity": {
        "access": "N/A",
        "search": "O(1)",
        "insertion": "O(1)",
        "deletion": "O(1)"
      },
      "space_complexity": "O(n)",
      "use_cases": ["Database indexing", "Caches", "Sets", "Associative arrays", "Symbol tables in compilers"],
      "implementations": {
        "python": "# Python Hash Table Implementation\nclass HashTable:\n    def __init__(self, size=10):\n        self.size = size\n        self.table = [[] for _ in range(size)]\n    \n    def _hash(self, key):\n        \"\"\"Simple hash function\"\"\"\n        return hash(key) % self.size\n    \n    def put(self, key, value):\n        \"\"\"Insert a key-value pair\"\"\"\n        index = self._hash(key)\n        bucket = self.table[index]\n        \n        # Check if key already exists\n        for i, (k, v) in enumerate(bucket):\n            if k == key:\n                bucket[i] = (key, value)\n                return\n        \n        # Add new key-value pair\n        bucket.append((key, value))\n    \n    def get(self, key):\n        \"\"\"Retrieve a value by key\"\"\"\n        index = self._hash(key)\n        bucket = self.table[index]\n        \n        for k, v in bucket:\n            if k == key:\n                return v\n        \n        raise KeyError(f\"Key '{key}' not found\")\n    \n    def remove(self, key):\n        \"\"\"Remove a key-value pair\"\"\"\n        index = self._hash(key)\n        bucket = self.table[index]\n        \n        for i, (k, v) in enumerate(bucket):\n            if k == key:\n                del bucket[i]\n                return\n        \n        raise KeyError(f\"Key '{key}' not found\")\n\n# Example usage\nht = HashTable()\nht.put(\"name\", \"John\")\nht.put(\"age\", 30)\nprint(ht.get(\"name\"))  # Output: John",
        "java": "// Java Hash Table Implementation\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class HashTable<K, V> {\n    private static class Entry<K, V> {\n        K key;\n        V value;\n        \n        Entry(K key, V value) {\n            this.key = key;\n            this.value = value;\n        }\n    }\n    \n    private List<Entry<K, V>>[] table;\n    private int size;\n    \n    @SuppressWarnings(\"unchecked\")\n    public HashTable(int size) {\n        this.size = size;\n        this.table = new List[size];\n        for (int i = 0; i < size; i++) {\n            table[i] = new ArrayList<>();\n        }\n    }\n    \n    public HashTable() {\n        this(10);\n    }\n    \n    private int hash(K key) {\n        return Math.abs(key.hashCode()) % size;\n    }\n    \n    public void put(K key, V value) {\n        int index = hash(key);\n        List<Entry<K, V>> bucket = table[index];\n        \n        // Check if key already exists\n        for (Entry<K, V> entry : bucket) {\n            if (entry.key.equals(key)) {\n                entry.value = value;\n                return;\n            }\n        }\n        \n        // Add new entry\n        bucket.add(new Entry<>(key, value));\n    }\n    \n    public V get(K key) {\n        int index = hash(key);\n        List<Entry<K, V>> bucket = table[index];\n        \n        for (Entry<K, V> entry : bucket) {\n            if (entry.key.equals(key)) {\n                return entry.value;\n            }\n        }\n        \n        throw new RuntimeException(\"Key not found: \" + key);\n    }\n    \n    public void remove(K key) {\n        int index = hash(key);\n        List<Entry<K, V>> bucket = table[index];\n        \n        bucket.removeIf(entry -> entry.key.equals(key));\n    }\n}",
        "csharp": "// C# Hash Table Implementation\nusing System;\nusing System.Collections.Generic;\n\npublic class HashTable<TKey, TValue>\n{\n    private class Entry\n    {\n        public TKey Key { get; set; }\n        public TValue Value { get; set; }\n        \n        public Entry(TKey key, TValue value)\n        {\n            Key = key;\n            Value = value;\n        }\n    }\n    \n    private List<Entry>[] table;\n    private int size;\n    \n    public HashTable(int size = 10)\n    {\n        this.size = size;\n        table = new List<Entry>[size];\n        for (int i = 0; i < size; i++)\n        {\n            table[i] = new List<Entry>();\n        }\n    }\n    \n    private int Hash(TKey key)\n    {\n        return Math.Abs(key.GetHashCode()) % size;\n    }\n    \n    public void Put(TKey key, TValue value)\n    {\n        int index = Hash(key);\n        List<Entry> bucket = table[index];\n        \n        // Check if key already exists\n        foreach (Entry entry in bucket)\n        {\n            if (entry.Key.Equals(key))\n            {\n                entry.Value = value;\n                return;\n            }\n        }\n        \n        // Add new entry\n        bucket.Add(new Entry(key, value));\n    }\n    \n    public TValue Get(TKey key)\n    {\n        int index = Hash(key);\n        List<Entry> bucket = table[index];\n        \n        foreach (Entry entry in bucket)\n        {\n            if (entry.Key.Equals(key))\n            {\n                return entry.Value;\n            }\n        }\n        \n        throw new KeyNotFoundException($\"Key not found: {key}\");\n    }\n    \n    public void Remove(TKey key)\n    {\n        int index = Hash(key);\n        List<Entry> bucket = table[index];\n        \n        bucket.RemoveAll(entry => entry.Key.Equals(key));\n    }\n}"
      }
    },
    {
      "id": 6,
      "name": "Binary Tree",
      "category": "Tree",
      "description": "A hierarchical data structure where each node has at most two children, referred to as left and right child",
      "time_complexity": {
        "access": "O(log n)",
        "search": "O(log n)",
        "insertion": "O(log n)",
        "deletion": "O(log n)"
      },
      "space_complexity": "O(n)",
      "use_cases": ["Expression parsing", "File system hierarchies", "Database indexing", "Decision trees"],
      "implementations": {
        "python": "# Python Binary Tree Implementation\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass BinaryTree:\n    def __init__(self):\n        self.root = None\n    \n    def insert(self, val):\n        \"\"\"Insert a value into the binary tree\"\"\"\n        if not self.root:\n            self.root = TreeNode(val)\n        else:\n            self._insert_recursive(self.root, val)\n    \n    def _insert_recursive(self, node, val):\n        if val < node.val:\n            if node.left is None:\n                node.left = TreeNode(val)\n            else:\n                self._insert_recursive(node.left, val)\n        else:\n            if node.right is None:\n                node.right = TreeNode(val)\n            else:\n                self._insert_recursive(node.right, val)\n    \n    def search(self, val):\n        \"\"\"Search for a value in the binary tree\"\"\"\n        return self._search_recursive(self.root, val)\n    \n    def _search_recursive(self, node, val):\n        if not node or node.val == val:\n            return node\n        \n        if val < node.val:\n            return self._search_recursive(node.left, val)\n        return self._search_recursive(node.right, val)\n    \n    def inorder_traversal(self):\n        \"\"\"Perform inorder traversal\"\"\"\n        result = []\n        self._inorder_recursive(self.root, result)\n        return result\n    \n    def _inorder_recursive(self, node, result):\n        if node:\n            self._inorder_recursive(node.left, result)\n            result.append(node.val)\n            self._inorder_recursive(node.right, result)",
        "java": "// Java Binary Tree Implementation\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    \n    TreeNode() {}\n    TreeNode(int val) { this.val = val; }\n    TreeNode(int val, TreeNode left, TreeNode right) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\npublic class BinaryTree {\n    private TreeNode root;\n    \n    public BinaryTree() {\n        this.root = null;\n    }\n    \n    public void insert(int val) {\n        root = insertRecursive(root, val);\n    }\n    \n    private TreeNode insertRecursive(TreeNode node, int val) {\n        if (node == null) {\n            return new TreeNode(val);\n        }\n        \n        if (val < node.val) {\n            node.left = insertRecursive(node.left, val);\n        } else {\n            node.right = insertRecursive(node.right, val);\n        }\n        \n        return node;\n    }\n    \n    public TreeNode search(int val) {\n        return searchRecursive(root, val);\n    }\n    \n    private TreeNode searchRecursive(TreeNode node, int val) {\n        if (node == null || node.val == val) {\n            return node;\n        }\n        \n        if (val < node.val) {\n            return searchRecursive(node.left, val);\n        }\n        return searchRecursive(node.right, val);\n    }\n    \n    public void inorderTraversal() {\n        inorderRecursive(root);\n    }\n    \n    private void inorderRecursive(TreeNode node) {\n        if (node != null) {\n            inorderRecursive(node.left);\n            System.out.print(node.val + \" \");\n            inorderRecursive(node.right);\n        }\n    }\n}",
        "csharp": "// C# Binary Tree Implementation\npublic class TreeNode\n{\n    public int Val { get; set; }\n    public TreeNode Left { get; set; }\n    public TreeNode Right { get; set; }\n    \n    public TreeNode(int val = 0, TreeNode left = null, TreeNode right = null)\n    {\n        Val = val;\n        Left = left;\n        Right = right;\n    }\n}\n\npublic class BinaryTree\n{\n    private TreeNode root;\n    \n    public BinaryTree()\n    {\n        root = null;\n    }\n    \n    public void Insert(int val)\n    {\n        root = InsertRecursive(root, val);\n    }\n    \n    private TreeNode InsertRecursive(TreeNode node, int val)\n    {\n        if (node == null)\n        {\n            return new TreeNode(val);\n        }\n        \n        if (val < node.Val)\n        {\n            node.Left = InsertRecursive(node.Left, val);\n        }\n        else\n        {\n            node.Right = InsertRecursive(node.Right, val);\n        }\n        \n        return node;\n    }\n    \n    public TreeNode Search(int val)\n    {\n        return SearchRecursive(root, val);\n    }\n    \n    private TreeNode SearchRecursive(TreeNode node, int val)\n    {\n        if (node == null || node.Val == val)\n        {\n            return node;\n        }\n        \n        if (val < node.Val)\n        {\n            return SearchRecursive(node.Left, val);\n        }\n        return SearchRecursive(node.Right, val);\n    }\n    \n    public List<int> InorderTraversal()\n    {\n        List<int> result = new List<int>();\n        InorderRecursive(root, result);\n        return result;\n    }\n    \n    private void InorderRecursive(TreeNode node, List<int> result)\n    {\n        if (node != null)\n        {\n            InorderRecursive(node.Left, result);\n            result.Add(node.Val);\n            InorderRecursive(node.Right, result);\n        }\n    }\n}"
      }
    },
    {
      "id": 7,
      "name": "Graph",
      "category": "Graph",
      "description": "A collection of vertices (nodes) connected by edges, used to represent relationships between entities",
      "time_complexity": {
        "access": "O(V + E)",
        "search": "O(V + E)",
        "insertion": "O(1)",
        "deletion": "O(V + E)"
      },
      "space_complexity": "O(V + E)",
      "use_cases": ["Social networks", "Route planning", "Network topology", "Dependency resolution"],
      "implementations": {
        "python": "# Python Graph Implementation (Adjacency List)\nfrom collections import defaultdict, deque\n\nclass Graph:\n    def __init__(self, directed=False):\n        self.graph = defaultdict(list)\n        self.directed = directed\n        self.vertices = set()\n    \n    def add_vertex(self, vertex):\n        \"\"\"Add a vertex to the graph\"\"\"\n        self.vertices.add(vertex)\n        if vertex not in self.graph:\n            self.graph[vertex] = []\n    \n    def add_edge(self, u, v, weight=1):\n        \"\"\"Add an edge between vertices u and v\"\"\"\n        self.add_vertex(u)\n        self.add_vertex(v)\n        \n        self.graph[u].append((v, weight))\n        if not self.directed:\n            self.graph[v].append((u, weight))\n    \n    def get_neighbors(self, vertex):\n        \"\"\"Get neighbors of a vertex\"\"\"\n        return self.graph.get(vertex, [])\n    \n    def has_edge(self, u, v):\n        \"\"\"Check if edge exists between u and v\"\"\"\n        neighbors = self.get_neighbors(u)\n        return any(neighbor[0] == v for neighbor in neighbors)\n    \n    def remove_edge(self, u, v):\n        \"\"\"Remove edge between u and v\"\"\"\n        if u in self.graph:\n            self.graph[u] = [(vertex, weight) for vertex, weight in self.graph[u] if vertex != v]\n        \n        if not self.directed and v in self.graph:\n            self.graph[v] = [(vertex, weight) for vertex, weight in self.graph[v] if vertex != u]\n    \n    def get_vertices(self):\n        \"\"\"Get all vertices in the graph\"\"\"\n        return list(self.vertices)\n    \n    def get_edges(self):\n        \"\"\"Get all edges in the graph\"\"\"\n        edges = []\n        for u in self.graph:\n            for v, weight in self.graph[u]:\n                if self.directed or u <= v:  # Avoid duplicates in undirected graph\n                    edges.append((u, v, weight))\n        return edges\n    \n    def __str__(self):\n        result = []\n        for vertex in sorted(self.vertices):\n            neighbors = [f\"{v}({w})\" for v, w in self.graph[vertex]]\n            result.append(f\"{vertex}: {', '.join(neighbors)}\")\n        return '\\n'.join(result)",
        "java": "// Java Graph Implementation (Adjacency List)\nimport java.util.*;\n\npublic class Graph<T> {\n    private Map<T, List<Edge<T>>> adjacencyList;\n    private boolean directed;\n    \n    public Graph(boolean directed) {\n        this.adjacencyList = new HashMap<>();\n        this.directed = directed;\n    }\n    \n    public Graph() {\n        this(false); // Default to undirected\n    }\n    \n    public static class Edge<T> {\n        T destination;\n        int weight;\n        \n        public Edge(T destination, int weight) {\n            this.destination = destination;\n            this.weight = weight;\n        }\n        \n        public Edge(T destination) {\n            this(destination, 1);\n        }\n    }\n    \n    public void addVertex(T vertex) {\n        adjacencyList.putIfAbsent(vertex, new ArrayList<>());\n    }\n    \n    public void addEdge(T source, T destination, int weight) {\n        addVertex(source);\n        addVertex(destination);\n        \n        adjacencyList.get(source).add(new Edge<>(destination, weight));\n        \n        if (!directed) {\n            adjacencyList.get(destination).add(new Edge<>(source, weight));\n        }\n    }\n    \n    public void addEdge(T source, T destination) {\n        addEdge(source, destination, 1);\n    }\n    \n    public List<Edge<T>> getNeighbors(T vertex) {\n        return adjacencyList.getOrDefault(vertex, new ArrayList<>());\n    }\n    \n    public boolean hasEdge(T source, T destination) {\n        List<Edge<T>> neighbors = getNeighbors(source);\n        return neighbors.stream().anyMatch(edge -> edge.destination.equals(destination));\n    }\n    \n    public void removeEdge(T source, T destination) {\n        List<Edge<T>> sourceNeighbors = adjacencyList.get(source);\n        if (sourceNeighbors != null) {\n            sourceNeighbors.removeIf(edge -> edge.destination.equals(destination));\n        }\n        \n        if (!directed) {\n            List<Edge<T>> destNeighbors = adjacencyList.get(destination);\n            if (destNeighbors != null) {\n                destNeighbors.removeIf(edge -> edge.destination.equals(source));\n            }\n        }\n    }\n    \n    public Set<T> getVertices() {\n        return adjacencyList.keySet();\n    }\n    \n    public int getVertexCount() {\n        return adjacencyList.size();\n    }\n    \n    public int getEdgeCount() {\n        int count = 0;\n        for (List<Edge<T>> edges : adjacencyList.values()) {\n            count += edges.size();\n        }\n        return directed ? count : count / 2;\n    }\n}",
        "csharp": "// C# Graph Implementation (Adjacency List)\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic class Graph<T>\n{\n    private Dictionary<T, List<Edge<T>>> adjacencyList;\n    private bool directed;\n    \n    public Graph(bool directed = false)\n    {\n        this.adjacencyList = new Dictionary<T, List<Edge<T>>>();\n        this.directed = directed;\n    }\n    \n    public class Edge<TVertex>\n    {\n        public TVertex Destination { get; set; }\n        public int Weight { get; set; }\n        \n        public Edge(TVertex destination, int weight = 1)\n        {\n            Destination = destination;\n            Weight = weight;\n        }\n    }\n    \n    public void AddVertex(T vertex)\n    {\n        if (!adjacencyList.ContainsKey(vertex))\n        {\n            adjacencyList[vertex] = new List<Edge<T>>();\n        }\n    }\n    \n    public void AddEdge(T source, T destination, int weight = 1)\n    {\n        AddVertex(source);\n        AddVertex(destination);\n        \n        adjacencyList[source].Add(new Edge<T>(destination, weight));\n        \n        if (!directed)\n        {\n            adjacencyList[destination].Add(new Edge<T>(source, weight));\n        }\n    }\n    \n    public List<Edge<T>> GetNeighbors(T vertex)\n    {\n        return adjacencyList.ContainsKey(vertex) ? adjacencyList[vertex] : new List<Edge<T>>();\n    }\n    \n    public bool HasEdge(T source, T destination)\n    {\n        var neighbors = GetNeighbors(source);\n        return neighbors.Any(edge => edge.Destination.Equals(destination));\n    }\n    \n    public void RemoveEdge(T source, T destination)\n    {\n        if (adjacencyList.ContainsKey(source))\n        {\n            adjacencyList[source].RemoveAll(edge => edge.Destination.Equals(destination));\n        }\n        \n        if (!directed && adjacencyList.ContainsKey(destination))\n        {\n            adjacencyList[destination].RemoveAll(edge => edge.Destination.Equals(source));\n        }\n    }\n    \n    public IEnumerable<T> GetVertices()\n    {\n        return adjacencyList.Keys;\n    }\n    \n    public int VertexCount => adjacencyList.Count;\n    \n    public int EdgeCount\n    {\n        get\n        {\n            int count = adjacencyList.Values.Sum(edges => edges.Count);\n            return directed ? count : count / 2;\n        }\n    }\n}"
      }
    },
    {
      "id": 8,
      "name": "Heap",
      "category": "Tree",
      "description": "A specialized tree-based data structure that satisfies the heap property, commonly used for priority queues",
      "time_complexity": {
        "access": "O(1)",
        "search": "O(n)",
        "insertion": "O(log n)",
        "deletion": "O(log n)"
      },
      "space_complexity": "O(n)",
      "use_cases": ["Priority queues", "Heap sort algorithm", "Graph algorithms (Dijkstra's)", "Task scheduling"],
      "implementations": {
        "python": "# Python Heap Implementation (Min Heap)\nclass MinHeap:\n    def __init__(self):\n        self.heap = []\n    \n    def parent(self, i):\n        \"\"\"Get parent index\"\"\"\n        return (i - 1) // 2\n    \n    def left_child(self, i):\n        \"\"\"Get left child index\"\"\"\n        return 2 * i + 1\n    \n    def right_child(self, i):\n        \"\"\"Get right child index\"\"\"\n        return 2 * i + 2\n    \n    def swap(self, i, j):\n        \"\"\"Swap elements at indices i and j\"\"\"\n        self.heap[i], self.heap[j] = self.heap[j], self.heap[i]\n    \n    def insert(self, value):\n        \"\"\"Insert a value into the heap\"\"\"\n        self.heap.append(value)\n        self._heapify_up(len(self.heap) - 1)\n    \n    def _heapify_up(self, i):\n        \"\"\"Maintain heap property upwards\"\"\"\n        while i > 0 and self.heap[self.parent(i)] > self.heap[i]:\n            self.swap(i, self.parent(i))\n            i = self.parent(i)\n    \n    def extract_min(self):\n        \"\"\"Remove and return the minimum element\"\"\"\n        if not self.heap:\n            raise IndexError(\"Heap is empty\")\n        \n        if len(self.heap) == 1:\n            return self.heap.pop()\n        \n        min_val = self.heap[0]\n        self.heap[0] = self.heap.pop()\n        self._heapify_down(0)\n        return min_val\n    \n    def _heapify_down(self, i):\n        \"\"\"Maintain heap property downwards\"\"\"\n        while self.left_child(i) < len(self.heap):\n            min_child_idx = self._get_min_child_idx(i)\n            \n            if self.heap[i] > self.heap[min_child_idx]:\n                self.swap(i, min_child_idx)\n                i = min_child_idx\n            else:\n                break\n    \n    def _get_min_child_idx(self, i):\n        \"\"\"Get index of minimum child\"\"\"\n        left = self.left_child(i)\n        right = self.right_child(i)\n        \n        if right >= len(self.heap):\n            return left\n        \n        return left if self.heap[left] < self.heap[right] else right\n    \n    def peek(self):\n        \"\"\"Get minimum element without removing it\"\"\"\n        if not self.heap:\n            raise IndexError(\"Heap is empty\")\n        return self.heap[0]\n    \n    def size(self):\n        \"\"\"Get heap size\"\"\"\n        return len(self.heap)\n    \n    def is_empty(self):\n        \"\"\"Check if heap is empty\"\"\"\n        return len(self.heap) == 0",
        "java": "// Java Heap Implementation (Min Heap)\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class MinHeap {\n    private List<Integer> heap;\n    \n    public MinHeap() {\n        heap = new ArrayList<>();\n    }\n    \n    private int parent(int i) {\n        return (i - 1) / 2;\n    }\n    \n    private int leftChild(int i) {\n        return 2 * i + 1;\n    }\n    \n    private int rightChild(int i) {\n        return 2 * i + 2;\n    }\n    \n    private void swap(int i, int j) {\n        int temp = heap.get(i);\n        heap.set(i, heap.get(j));\n        heap.set(j, temp);\n    }\n    \n    public void insert(int value) {\n        heap.add(value);\n        heapifyUp(heap.size() - 1);\n    }\n    \n    private void heapifyUp(int i) {\n        while (i > 0 && heap.get(parent(i)) > heap.get(i)) {\n            swap(i, parent(i));\n            i = parent(i);\n        }\n    }\n    \n    public int extractMin() {\n        if (heap.isEmpty()) {\n            throw new RuntimeException(\"Heap is empty\");\n        }\n        \n        if (heap.size() == 1) {\n            return heap.remove(0);\n        }\n        \n        int min = heap.get(0);\n        heap.set(0, heap.remove(heap.size() - 1));\n        heapifyDown(0);\n        return min;\n    }\n    \n    private void heapifyDown(int i) {\n        while (leftChild(i) < heap.size()) {\n            int minChildIdx = getMinChildIdx(i);\n            \n            if (heap.get(i) > heap.get(minChildIdx)) {\n                swap(i, minChildIdx);\n                i = minChildIdx;\n            } else {\n                break;\n            }\n        }\n    }\n    \n    private int getMinChildIdx(int i) {\n        int left = leftChild(i);\n        int right = rightChild(i);\n        \n        if (right >= heap.size()) {\n            return left;\n        }\n        \n        return heap.get(left) < heap.get(right) ? left : right;\n    }\n    \n    public int peek() {\n        if (heap.isEmpty()) {\n            throw new RuntimeException(\"Heap is empty\");\n        }\n        return heap.get(0);\n    }\n    \n    public int size() {\n        return heap.size();\n    }\n    \n    public boolean isEmpty() {\n        return heap.isEmpty();\n    }\n}",
        "csharp": "// C# Heap Implementation (Min Heap)\nusing System;\nusing System.Collections.Generic;\n\npublic class MinHeap\n{\n    private List<int> heap;\n    \n    public MinHeap()\n    {\n        heap = new List<int>();\n    }\n    \n    private int Parent(int i)\n    {\n        return (i - 1) / 2;\n    }\n    \n    private int LeftChild(int i)\n    {\n        return 2 * i + 1;\n    }\n    \n    private int RightChild(int i)\n    {\n        return 2 * i + 2;\n    }\n    \n    private void Swap(int i, int j)\n    {\n        int temp = heap[i];\n        heap[i] = heap[j];\n        heap[j] = temp;\n    }\n    \n    public void Insert(int value)\n    {\n        heap.Add(value);\n        HeapifyUp(heap.Count - 1);\n    }\n    \n    private void HeapifyUp(int i)\n    {\n        while (i > 0 && heap[Parent(i)] > heap[i])\n        {\n            Swap(i, Parent(i));\n            i = Parent(i);\n        }\n    }\n    \n    public int ExtractMin()\n    {\n        if (heap.Count == 0)\n        {\n            throw new InvalidOperationException(\"Heap is empty\");\n        }\n        \n        if (heap.Count == 1)\n        {\n            int lastElement = heap[0];\n            heap.RemoveAt(0);\n            return lastElement;\n        }\n        \n        int min = heap[0];\n        heap[0] = heap[heap.Count - 1];\n        heap.RemoveAt(heap.Count - 1);\n        HeapifyDown(0);\n        return min;\n    }\n    \n    private void HeapifyDown(int i)\n    {\n        while (LeftChild(i) < heap.Count)\n        {\n            int minChildIdx = GetMinChildIdx(i);\n            \n            if (heap[i] > heap[minChildIdx])\n            {\n                Swap(i, minChildIdx);\n                i = minChildIdx;\n            }\n            else\n            {\n                break;\n            }\n        }\n    }\n    \n    private int GetMinChildIdx(int i)\n    {\n        int left = LeftChild(i);\n        int right = RightChild(i);\n        \n        if (right >= heap.Count)\n        {\n            return left;\n        }\n        \n        return heap[left] < heap[right] ? left : right;\n    }\n    \n    public int Peek()\n    {\n        if (heap.Count == 0)\n        {\n            throw new InvalidOperationException(\"Heap is empty\");\n        }\n        return heap[0];\n    }\n    \n    public int Size => heap.Count;\n    \n    public bool IsEmpty => heap.Count == 0;\n}"
      }
    },
    {
      "id": 9,
      "name": "Trie",
      "category": "Tree",
      "description": "A tree-like data structure used to store a dynamic set of strings, where each node represents a character",
      "time_complexity": {
        "access": "O(m)",
        "search": "O(m)",
        "insertion": "O(m)",
        "deletion": "O(m)"
      },
      "space_complexity": "O(ALPHABET_SIZE * N * M)",
      "use_cases": ["Auto-complete features", "Spell checkers", "IP routing", "Dictionary implementations"],
      "implementations": {
        "python": "# Python Trie Implementation\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n        self.word_count = 0  # Number of words ending at this node\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n    \n    def insert(self, word):\n        \"\"\"Insert a word into the trie\"\"\"\n        node = self.root\n        \n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        \n        node.is_end_of_word = True\n        node.word_count += 1\n    \n    def search(self, word):\n        \"\"\"Search for a word in the trie\"\"\"\n        node = self._find_node(word)\n        return node is not None and node.is_end_of_word\n    \n    def starts_with(self, prefix):\n        \"\"\"Check if any word starts with the given prefix\"\"\"\n        return self._find_node(prefix) is not None\n    \n    def _find_node(self, prefix):\n        \"\"\"Helper method to find node for given prefix\"\"\"\n        node = self.root\n        \n        for char in prefix:\n            if char not in node.children:\n                return None\n            node = node.children[char]\n        \n        return node\n    \n    def delete(self, word):\n        \"\"\"Delete a word from the trie\"\"\"\n        def _delete_recursive(node, word, index):\n            if index == len(word):\n                # We've reached the end of the word\n                if not node.is_end_of_word:\n                    return False  # Word doesn't exist\n                \n                node.is_end_of_word = False\n                node.word_count = 0\n                \n                # Return True if node has no children (can be deleted)\n                return len(node.children) == 0\n            \n            char = word[index]\n            child_node = node.children.get(char)\n            \n            if not child_node:\n                return False  # Word doesn't exist\n            \n            should_delete_child = _delete_recursive(child_node, word, index + 1)\n            \n            if should_delete_child:\n                del node.children[char]\n                # Return True if node is not end of word and has no children\n                return not node.is_end_of_word and len(node.children) == 0\n            \n            return False\n        \n        _delete_recursive(self.root, word, 0)\n    \n    def get_all_words_with_prefix(self, prefix):\n        \"\"\"Get all words that start with the given prefix\"\"\"\n        words = []\n        prefix_node = self._find_node(prefix)\n        \n        if prefix_node:\n            self._collect_words(prefix_node, prefix, words)\n        \n        return words\n    \n    def _collect_words(self, node, current_word, words):\n        \"\"\"Helper method to collect all words from a node\"\"\"\n        if node.is_end_of_word:\n            words.append(current_word)\n        \n        for char, child_node in node.children.items():\n            self._collect_words(child_node, current_word + char, words)\n    \n    def count_words(self):\n        \"\"\"Count total number of words in the trie\"\"\"\n        return self._count_words_recursive(self.root)\n    \n    def _count_words_recursive(self, node):\n        \"\"\"Helper method to count words recursively\"\"\"\n        count = node.word_count\n        for child in node.children.values():\n            count += self._count_words_recursive(child)\n        return count",
        "java": "// Java Trie Implementation\nimport java.util.*;\n\nclass TrieNode {\n    Map<Character, TrieNode> children;\n    boolean isEndOfWord;\n    int wordCount;\n    \n    public TrieNode() {\n        children = new HashMap<>();\n        isEndOfWord = false;\n        wordCount = 0;\n    }\n}\n\npublic class Trie {\n    private TrieNode root;\n    \n    public Trie() {\n        root = new TrieNode();\n    }\n    \n    public void insert(String word) {\n        TrieNode node = root;\n        \n        for (char ch : word.toCharArray()) {\n            node.children.putIfAbsent(ch, new TrieNode());\n            node = node.children.get(ch);\n        }\n        \n        node.isEndOfWord = true;\n        node.wordCount++;\n    }\n    \n    public boolean search(String word) {\n        TrieNode node = findNode(word);\n        return node != null && node.isEndOfWord;\n    }\n    \n    public boolean startsWith(String prefix) {\n        return findNode(prefix) != null;\n    }\n    \n    private TrieNode findNode(String prefix) {\n        TrieNode node = root;\n        \n        for (char ch : prefix.toCharArray()) {\n            if (!node.children.containsKey(ch)) {\n                return null;\n            }\n            node = node.children.get(ch);\n        }\n        \n        return node;\n    }\n    \n    public void delete(String word) {\n        deleteRecursive(root, word, 0);\n    }\n    \n    private boolean deleteRecursive(TrieNode node, String word, int index) {\n        if (index == word.length()) {\n            if (!node.isEndOfWord) {\n                return false;\n            }\n            \n            node.isEndOfWord = false;\n            node.wordCount = 0;\n            \n            return node.children.isEmpty();\n        }\n        \n        char ch = word.charAt(index);\n        TrieNode childNode = node.children.get(ch);\n        \n        if (childNode == null) {\n            return false;\n        }\n        \n        boolean shouldDeleteChild = deleteRecursive(childNode, word, index + 1);\n        \n        if (shouldDeleteChild) {\n            node.children.remove(ch);\n            return !node.isEndOfWord && node.children.isEmpty();\n        }\n        \n        return false;\n    }\n    \n    public List<String> getAllWordsWithPrefix(String prefix) {\n        List<String> words = new ArrayList<>();\n        TrieNode prefixNode = findNode(prefix);\n        \n        if (prefixNode != null) {\n            collectWords(prefixNode, prefix, words);\n        }\n        \n        return words;\n    }\n    \n    private void collectWords(TrieNode node, String currentWord, List<String> words) {\n        if (node.isEndOfWord) {\n            words.add(currentWord);\n        }\n        \n        for (Map.Entry<Character, TrieNode> entry : node.children.entrySet()) {\n            collectWords(entry.getValue(), currentWord + entry.getKey(), words);\n        }\n    }\n    \n    public int countWords() {\n        return countWordsRecursive(root);\n    }\n    \n    private int countWordsRecursive(TrieNode node) {\n        int count = node.wordCount;\n        for (TrieNode child : node.children.values()) {\n            count += countWordsRecursive(child);\n        }\n        return count;\n    }\n}",
        "csharp": "// C# Trie Implementation\nusing System;\nusing System.Collections.Generic;\n\npublic class TrieNode\n{\n    public Dictionary<char, TrieNode> Children { get; set; }\n    public bool IsEndOfWord { get; set; }\n    public int WordCount { get; set; }\n    \n    public TrieNode()\n    {\n        Children = new Dictionary<char, TrieNode>();\n        IsEndOfWord = false;\n        WordCount = 0;\n    }\n}\n\npublic class Trie\n{\n    private TrieNode root;\n    \n    public Trie()\n    {\n        root = new TrieNode();\n    }\n    \n    public void Insert(string word)\n    {\n        TrieNode node = root;\n        \n        foreach (char ch in word)\n        {\n            if (!node.Children.ContainsKey(ch))\n            {\n                node.Children[ch] = new TrieNode();\n            }\n            node = node.Children[ch];\n        }\n        \n        node.IsEndOfWord = true;\n        node.WordCount++;\n    }\n    \n    public bool Search(string word)\n    {\n        TrieNode node = FindNode(word);\n        return node != null && node.IsEndOfWord;\n    }\n    \n    public bool StartsWith(string prefix)\n    {\n        return FindNode(prefix) != null;\n    }\n    \n    private TrieNode FindNode(string prefix)\n    {\n        TrieNode node = root;\n        \n        foreach (char ch in prefix)\n        {\n            if (!node.Children.ContainsKey(ch))\n            {\n                return null;\n            }\n            node = node.Children[ch];\n        }\n        \n        return node;\n    }\n    \n    public void Delete(string word)\n    {\n        DeleteRecursive(root, word, 0);\n    }\n    \n    private bool DeleteRecursive(TrieNode node, string word, int index)\n    {\n        if (index == word.Length)\n        {\n            if (!node.IsEndOfWord)\n            {\n                return false;\n            }\n            \n            node.IsEndOfWord = false;\n            node.WordCount = 0;\n            \n            return node.Children.Count == 0;\n        }\n        \n        char ch = word[index];\n        if (!node.Children.ContainsKey(ch))\n        {\n            return false;\n        }\n        \n        TrieNode childNode = node.Children[ch];\n        bool shouldDeleteChild = DeleteRecursive(childNode, word, index + 1);\n        \n        if (shouldDeleteChild)\n        {\n            node.Children.Remove(ch);\n            return !node.IsEndOfWord && node.Children.Count == 0;\n        }\n        \n        return false;\n    }\n    \n    public List<string> GetAllWordsWithPrefix(string prefix)\n    {\n        List<string> words = new List<string>();\n        TrieNode prefixNode = FindNode(prefix);\n        \n        if (prefixNode != null)\n        {\n            CollectWords(prefixNode, prefix, words);\n        }\n        \n        return words;\n    }\n    \n    private void CollectWords(TrieNode node, string currentWord, List<string> words)\n    {\n        if (node.IsEndOfWord)\n        {\n            words.Add(currentWord);\n        }\n        \n        foreach (var kvp in node.Children)\n        {\n            CollectWords(kvp.Value, currentWord + kvp.Key, words);\n        }\n    }\n    \n    public int CountWords()\n    {\n        return CountWordsRecursive(root);\n    }\n    \n    private int CountWordsRecursive(TrieNode node)\n    {\n        int count = node.WordCount;\n        foreach (TrieNode child in node.Children.Values)\n        {\n            count += CountWordsRecursive(child);\n        }\n        return count;\n    }\n}"
      }
    },
     {
      "id": 10,
      "name": "Deque (Double-ended Queue)",
      "category": "Queue",
      "description": "A linear data structure that allows insertion and deletion at both ends",
      "time_complexity": {
        "access": "O(1)",
        "search": "O(n)",
        "insertion": "O(1)",
        "deletion": "O(1)"
      },
      "space_complexity": "O(n)",
      "use_cases": ["Sliding window problems", "Palindrome checking", "Undo-redo operations", "Browser history"],
      "implementations": {
        "python": "# Python Deque Implementation\nfrom collections import deque as built_in_deque\n\nclass Deque:\n    def __init__(self):\n        self.items = []\n    \n    def add_front(self, item):\n        \"\"\"Add an item to the front of the deque\"\"\"\n        self.items.insert(0, item)\n    \n    def add_rear(self, item):\n        \"\"\"Add an item to the rear of the deque\"\"\"\n        self.items.append(item)\n    \n    def remove_front(self):\n        \"\"\"Remove and return the front item\"\"\"\n        if self.is_empty():\n            raise IndexError(\"Deque is empty\")\n        return self.items.pop(0)\n    \n    def remove_rear(self):\n        \"\"\"Remove and return the rear item\"\"\"\n        if self.is_empty():\n            raise IndexError(\"Deque is empty\")\n        return self.items.pop()\n    \n    def peek_front(self):\n        \"\"\"Return the front item without removing it\"\"\"\n        if self.is_empty():\n            raise IndexError(\"Deque is empty\")\n        return self.items[0]\n    \n    def peek_rear(self):\n        \"\"\"Return the rear item without removing it\"\"\"\n        if self.is_empty():\n            raise IndexError(\"Deque is empty\")\n        return self.items[-1]\n    \n    def is_empty(self):\n        \"\"\"Check if the deque is empty\"\"\"\n        return len(self.items) == 0\n    \n    def size(self):\n        \"\"\"Return the number of items in the deque\"\"\"\n        return len(self.items)\n    \n    def __str__(self):\n        return f\"Deque({self.items})\"\n\n# More efficient implementation using circular buffer\nclass CircularDeque:\n    def __init__(self, capacity=10):\n        self.capacity = capacity\n        self.buffer = [None] * capacity\n        self.front = 0\n        self.rear = 0\n        self.size = 0\n    \n    def add_front(self, item):\n        if self.size == self.capacity:\n            raise OverflowError(\"Deque is full\")\n        \n        self.front = (self.front - 1) % self.capacity\n        self.buffer[self.front] = item\n        self.size += 1\n    \n    def add_rear(self, item):\n        if self.size == self.capacity:\n            raise OverflowError(\"Deque is full\")\n        \n        self.buffer[self.rear] = item\n        self.rear = (self.rear + 1) % self.capacity\n        self.size += 1\n    \n    def remove_front(self):\n        if self.size == 0:\n            raise IndexError(\"Deque is empty\")\n        \n        item = self.buffer[self.front]\n        self.buffer[self.front] = None\n        self.front = (self.front + 1) % self.capacity\n        self.size -= 1\n        return item\n    \n    def remove_rear(self):\n        if self.size == 0:\n            raise IndexError(\"Deque is empty\")\n        \n        self.rear = (self.rear - 1) % self.capacity\n        item = self.buffer[self.rear]\n        self.buffer[self.rear] = None\n        self.size -= 1\n        return item\n\n# Example usage\ndq = Deque()\ndq.add_front(1)\ndq.add_rear(2)\ndq.add_front(0)\nprint(dq)  # Output: Deque([0, 1, 2])\nprint(dq.remove_front())  # Output: 0\nprint(dq.remove_rear())   # Output: 2",
        "java": "// Java Deque Implementation\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Deque<T> {\n    private List<T> items;\n    \n    public Deque() {\n        items = new ArrayList<>();\n    }\n    \n    public void addFront(T item) {\n        items.add(0, item);\n    }\n    \n    public void addRear(T item) {\n        items.add(item);\n    }\n    \n    public T removeFront() {\n        if (isEmpty()) {\n            throw new RuntimeException(\"Deque is empty\");\n        }\n        return items.remove(0);\n    }\n    \n    public T removeRear() {\n        if (isEmpty()) {\n            throw new RuntimeException(\"Deque is empty\");\n        }\n        return items.remove(items.size() - 1);\n    }\n    \n    public T peekFront() {\n        if (isEmpty()) {\n            throw new RuntimeException(\"Deque is empty\");\n        }\n        return items.get(0);\n    }\n    \n    public T peekRear() {\n        if (isEmpty()) {\n            throw new RuntimeException(\"Deque is empty\");\n        }\n        return items.get(items.size() - 1);\n    }\n    \n    public boolean isEmpty() {\n        return items.isEmpty();\n    }\n    \n    public int size() {\n        return items.size();\n    }\n    \n    @Override\n    public String toString() {\n        return \"Deque\" + items.toString();\n    }\n}\n\n// More efficient circular buffer implementation\nclass CircularDeque<T> {\n    private Object[] buffer;\n    private int front;\n    private int rear;\n    private int size;\n    private int capacity;\n    \n    public CircularDeque(int capacity) {\n        this.capacity = capacity;\n        this.buffer = new Object[capacity];\n        this.front = 0;\n        this.rear = 0;\n        this.size = 0;\n    }\n    \n    public CircularDeque() {\n        this(10);\n    }\n    \n    public void addFront(T item) {\n        if (size == capacity) {\n            throw new RuntimeException(\"Deque is full\");\n        }\n        \n        front = (front - 1 + capacity) % capacity;\n        buffer[front] = item;\n        size++;\n    }\n    \n    public void addRear(T item) {\n        if (size == capacity) {\n            throw new RuntimeException(\"Deque is full\");\n        }\n        \n        buffer[rear] = item;\n        rear = (rear + 1) % capacity;\n        size++;\n    }\n    \n    @SuppressWarnings(\"unchecked\")\n    public T removeFront() {\n        if (size == 0) {\n            throw new RuntimeException(\"Deque is empty\");\n        }\n        \n        T item = (T) buffer[front];\n        buffer[front] = null;\n        front = (front + 1) % capacity;\n        size--;\n        return item;\n    }\n    \n    @SuppressWarnings(\"unchecked\")\n    public T removeRear() {\n        if (size == 0) {\n            throw new RuntimeException(\"Deque is empty\");\n        }\n        \n        rear = (rear - 1 + capacity) % capacity;\n        T item = (T) buffer[rear];\n        buffer[rear] = null;\n        size--;\n        return item;\n    }\n    \n    public int size() {\n        return size;\n    }\n    \n    public boolean isEmpty() {\n        return size == 0;\n    }\n}",
        "csharp": "// C# Deque Implementation\nusing System;\nusing System.Collections.Generic;\n\npublic class Deque<T>\n{\n    private List<T> items;\n    \n    public Deque()\n    {\n        items = new List<T>();\n    }\n    \n    public void AddFront(T item)\n    {\n        items.Insert(0, item);\n    }\n    \n    public void AddRear(T item)\n    {\n        items.Add(item);\n    }\n    \n    public T RemoveFront()\n    {\n        if (IsEmpty())\n        {\n            throw new InvalidOperationException(\"Deque is empty\");\n        }\n        T item = items[0];\n        items.RemoveAt(0);\n        return item;\n    }\n    \n    public T RemoveRear()\n    {\n        if (IsEmpty())\n        {\n            throw new InvalidOperationException(\"Deque is empty\");\n        }\n        T item = items[items.Count - 1];\n        items.RemoveAt(items.Count - 1);\n        return item;\n    }\n    \n    public T PeekFront()\n    {\n        if (IsEmpty())\n        {\n            throw new InvalidOperationException(\"Deque is empty\");\n        }\n        return items[0];\n    }\n    \n    public T PeekRear()\n    {\n        if (IsEmpty())\n        {\n            throw new InvalidOperationException(\"Deque is empty\");\n        }\n        return items[items.Count - 1];\n    }\n    \n    public bool IsEmpty()\n    {\n        return items.Count == 0;\n    }\n    \n    public int Size()\n    {\n        return items.Count;\n    }\n    \n    public override string ToString()\n    {\n        return $\"Deque[{string.Join(\", \", items)}]\";\n    }\n}\n\n// More efficient circular buffer implementation\npublic class CircularDeque<T>\n{\n    private T[] buffer;\n    private int front;\n    private int rear;\n    private int size;\n    private int capacity;\n    \n    public CircularDeque(int capacity = 10)\n    {\n        this.capacity = capacity;\n        buffer = new T[capacity];\n        front = 0;\n        rear = 0;\n        size = 0;\n    }\n    \n    public void AddFront(T item)\n    {\n        if (size == capacity)\n        {\n            throw new InvalidOperationException(\"Deque is full\");\n        }\n        \n        front = (front - 1 + capacity) % capacity;\n        buffer[front] = item;\n        size++;\n    }\n    \n    public void AddRear(T item)\n    {\n        if (size == capacity)\n        {\n            throw new InvalidOperationException(\"Deque is full\");\n        }\n        \n        buffer[rear] = item;\n        rear = (rear + 1) % capacity;\n        size++;\n    }\n    \n    public T RemoveFront()\n    {\n        if (size == 0)\n        {\n            throw new InvalidOperationException(\"Deque is empty\");\n        }\n        \n        T item = buffer[front];\n        buffer[front] = default(T);\n        front = (front + 1) % capacity;\n        size--;\n        return item;\n    }\n    \n    public T RemoveRear()\n    {\n        if (size == 0)\n        {\n            throw new InvalidOperationException(\"Deque is empty\");\n        }\n        \n        rear = (rear - 1 + capacity) % capacity;\n        T item = buffer[rear];\n        buffer[rear] = default(T);\n        size--;\n        return item;\n    }\n    \n    public int Size => size;\n    \n    public bool IsEmpty => size == 0;\n}"
      }
    },
    {
      "id": 11,
      "name": "Disjoint Set (Union-Find)",
      "category": "Tree",
      "description": "A data structure that keeps track of a set of elements partitioned into disjoint subsets",
      "time_complexity": {
        "access": "O(α(n))",
        "search": "O(α(n))",
        "insertion": "O(α(n))",
        "deletion": "N/A"
      },
      "space_complexity": "O(n)",
      "use_cases": ["Kruskal's algorithm", "Connected components", "Cycle detection", "Dynamic connectivity"],
      "implementations": {
        "python": "# Python Disjoint Set (Union-Find) Implementation\nclass UnionFind:\n    def __init__(self, n):\n        \"\"\"Initialize Union-Find with n elements\"\"\"\n        self.parent = list(range(n))\n        self.rank = [0] * n\n        self.components = n\n    \n    def find(self, x):\n        \"\"\"Find the root of element x with path compression\"\"\"\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])  # Path compression\n        return self.parent[x]\n    \n    def union(self, x, y):\n        \"\"\"Union two sets containing x and y\"\"\"\n        root_x = self.find(x)\n        root_y = self.find(y)\n        \n        if root_x == root_y:\n            return False  # Already in same set\n        \n        # Union by rank\n        if self.rank[root_x] < self.rank[root_y]:\n            self.parent[root_x] = root_y\n        elif self.rank[root_x] > self.rank[root_y]:\n            self.parent[root_y] = root_x\n        else:\n            self.parent[root_y] = root_x\n            self.rank[root_x] += 1\n        \n        self.components -= 1\n        return True\n    \n    def connected(self, x, y):\n        \"\"\"Check if x and y are in the same set\"\"\"\n        return self.find(x) == self.find(y)\n    \n    def get_components(self):\n        \"\"\"Get number of connected components\"\"\"\n        return self.components\n    \n    def get_component_size(self, x):\n        \"\"\"Get size of component containing x\"\"\"\n        root = self.find(x)\n        return sum(1 for i in range(len(self.parent)) if self.find(i) == root)\n    \n    def get_all_components(self):\n        \"\"\"Get all components as a dictionary\"\"\"\n        components = {}\n        for i in range(len(self.parent)):\n            root = self.find(i)\n            if root not in components:\n                components[root] = []\n            components[root].append(i)\n        return components\n\n# Alternative implementation with size tracking\nclass WeightedUnionFind:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.size = [1] * n\n        self.components = n\n    \n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n    \n    def union(self, x, y):\n        root_x = self.find(x)\n        root_y = self.find(y)\n        \n        if root_x == root_y:\n            return False\n        \n        # Union by size (attach smaller tree to larger tree)\n        if self.size[root_x] < self.size[root_y]:\n            self.parent[root_x] = root_y\n            self.size[root_y] += self.size[root_x]\n        else:\n            self.parent[root_y] = root_x\n            self.size[root_x] += self.size[root_y]\n        \n        self.components -= 1\n        return True\n    \n    def connected(self, x, y):\n        return self.find(x) == self.find(y)\n    \n    def component_size(self, x):\n        return self.size[self.find(x)]\n\n# Example usage\nuf = UnionFind(6)\nprint(f\"Initial components: {uf.get_components()}\")  # 6\n\nuf.union(0, 1)\nuf.union(2, 3)\nuf.union(0, 2)\nprint(f\"After unions: {uf.get_components()}\")  # 3\nprint(f\"0 and 3 connected: {uf.connected(0, 3)}\")  # True\nprint(f\"1 and 4 connected: {uf.connected(1, 4)}\")  # False",
        "java": "// Java Disjoint Set (Union-Find) Implementation\nimport java.util.*;\n\npublic class UnionFind {\n    private int[] parent;\n    private int[] rank;\n    private int components;\n    \n    public UnionFind(int n) {\n        parent = new int[n];\n        rank = new int[n];\n        components = n;\n        \n        for (int i = 0; i < n; i++) {\n            parent[i] = i;\n            rank[i] = 0;\n        }\n    }\n    \n    public int find(int x) {\n        if (parent[x] != x) {\n            parent[x] = find(parent[x]); // Path compression\n        }\n        return parent[x];\n    }\n    \n    public boolean union(int x, int y) {\n        int rootX = find(x);\n        int rootY = find(y);\n        \n        if (rootX == rootY) {\n            return false; // Already in same set\n        }\n        \n        // Union by rank\n        if (rank[rootX] < rank[rootY]) {\n            parent[rootX] = rootY;\n        } else if (rank[rootX] > rank[rootY]) {\n            parent[rootY] = rootX;\n        } else {\n            parent[rootY] = rootX;\n            rank[rootX]++;\n        }\n        \n        components--;\n        return true;\n    }\n    \n    public boolean connected(int x, int y) {\n        return find(x) == find(y);\n    }\n    \n    public int getComponents() {\n        return components;\n    }\n    \n    public int getComponentSize(int x) {\n        int root = find(x);\n        int size = 0;\n        for (int i = 0; i < parent.length; i++) {\n            if (find(i) == root) {\n                size++;\n            }\n        }\n        return size;\n    }\n    \n    public Map<Integer, List<Integer>> getAllComponents() {\n        Map<Integer, List<Integer>> components = new HashMap<>();\n        for (int i = 0; i < parent.length; i++) {\n            int root = find(i);\n            components.computeIfAbsent(root, k -> new ArrayList<>()).add(i);\n        }\n        return components;\n    }\n}\n\n// Alternative implementation with size tracking\nclass WeightedUnionFind {\n    private int[] parent;\n    private int[] size;\n    private int components;\n    \n    public WeightedUnionFind(int n) {\n        parent = new int[n];\n        size = new int[n];\n        components = n;\n        \n        for (int i = 0; i < n; i++) {\n            parent[i] = i;\n            size[i] = 1;\n        }\n    }\n    \n    public int find(int x) {\n        if (parent[x] != x) {\n            parent[x] = find(parent[x]);\n        }\n        return parent[x];\n    }\n    \n    public boolean union(int x, int y) {\n        int rootX = find(x);\n        int rootY = find(y);\n        \n        if (rootX == rootY) {\n            return false;\n        }\n        \n        // Union by size\n        if (size[rootX] < size[rootY]) {\n            parent[rootX] = rootY;\n            size[rootY] += size[rootX];\n        } else {\n            parent[rootY] = rootX;\n            size[rootX] += size[rootY];\n        }\n        \n        components--;\n        return true;\n    }\n    \n    public boolean connected(int x, int y) {\n        return find(x) == find(y);\n    }\n    \n    public int componentSize(int x) {\n        return size[find(x)];\n    }\n    \n    public int getComponents() {\n        return components;\n    }\n    \n    // Example usage\n    public static void main(String[] args) {\n        UnionFind uf = new UnionFind(6);\n        System.out.println(\"Initial components: \" + uf.getComponents()); // 6\n        \n        uf.union(0, 1);\n        uf.union(2, 3);\n        uf.union(0, 2);\n        System.out.println(\"After unions: \" + uf.getComponents()); // 3\n        System.out.println(\"0 and 3 connected: \" + uf.connected(0, 3)); // true\n        System.out.println(\"1 and 4 connected: \" + uf.connected(1, 4)); // false\n    }\n}",
        "csharp": "// C# Disjoint Set (Union-Find) Implementation\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic class UnionFind\n{\n    private int[] parent;\n    private int[] rank;\n    private int components;\n    \n    public UnionFind(int n)\n    {\n        parent = new int[n];\n        rank = new int[n];\n        components = n;\n        \n        for (int i = 0; i < n; i++)\n        {\n            parent[i] = i;\n            rank[i] = 0;\n        }\n    }\n    \n    public int Find(int x)\n    {\n        if (parent[x] != x)\n        {\n            parent[x] = Find(parent[x]); // Path compression\n        }\n        return parent[x];\n    }\n    \n    public bool Union(int x, int y)\n    {\n        int rootX = Find(x);\n        int rootY = Find(y);\n        \n        if (rootX == rootY)\n        {\n            return false; // Already in same set\n        }\n        \n        // Union by rank\n        if (rank[rootX] < rank[rootY])\n        {\n            parent[rootX] = rootY;\n        }\n        else if (rank[rootX] > rank[rootY])\n        {\n            parent[rootY] = rootX;\n        }\n        else\n        {\n            parent[rootY] = rootX;\n            rank[rootX]++;\n        }\n        \n        components--;\n        return true;\n    }\n    \n    public bool Connected(int x, int y)\n    {\n        return Find(x) == Find(y);\n    }\n    \n    public int GetComponents()\n    {\n        return components;\n    }\n    \n    public int GetComponentSize(int x)\n    {\n        int root = Find(x);\n        return parent.Where((p, i) => Find(i) == root).Count();\n    }\n    \n    public Dictionary<int, List<int>> GetAllComponents()\n    {\n        var components = new Dictionary<int, List<int>>();\n        for (int i = 0; i < parent.Length; i++)\n        {\n            int root = Find(i);\n            if (!components.ContainsKey(root))\n            {\n                components[root] = new List<int>();\n            }\n            components[root].Add(i);\n        }\n        return components;\n    }\n}\n\n// Alternative implementation with size tracking\npublic class WeightedUnionFind\n{\n    private int[] parent;\n    private int[] size;\n    private int components;\n    \n    public WeightedUnionFind(int n)\n    {\n        parent = new int[n];\n        size = new int[n];\n        components = n;\n        \n        for (int i = 0; i < n; i++)\n        {\n            parent[i] = i;\n            size[i] = 1;\n        }\n    }\n    \n    public int Find(int x)\n    {\n        if (parent[x] != x)\n        {\n            parent[x] = Find(parent[x]);\n        }\n        return parent[x];\n    }\n    \n    public bool Union(int x, int y)\n    {\n        int rootX = Find(x);\n        int rootY = Find(y);\n        \n        if (rootX == rootY)\n        {\n            return false;\n        }\n        \n        // Union by size\n        if (size[rootX] < size[rootY])\n        {\n            parent[rootX] = rootY;\n            size[rootY] += size[rootX];\n        }\n        else\n        {\n            parent[rootY] = rootX;\n            size[rootX] += size[rootY];\n        }\n        \n        components--;\n        return true;\n    }\n    \n    public bool Connected(int x, int y)\n    {\n        return Find(x) == Find(y);\n    }\n    \n    public int ComponentSize(int x)\n    {\n        return size[Find(x)];\n    }\n    \n    public int GetComponents()\n    {\n        return components;\n    }\n    \n    // Example usage\n    static void Main(string[] args)\n    {\n        UnionFind uf = new UnionFind(6);\n        Console.WriteLine($\"Initial components: {uf.GetComponents()}\"); // 6\n        \n        uf.Union(0, 1);\n        uf.Union(2, 3);\n        uf.Union(0, 2);\n        Console.WriteLine($\"After unions: {uf.GetComponents()}\"); // 3\n        Console.WriteLine($\"0 and 3 connected: {uf.Connected(0, 3)}\"); // True\n        Console.WriteLine($\"1 and 4 connected: {uf.Connected(1, 4)}\"); // False\n    }\n}"
      }
    }
  ],
  "algorithms": [
    {
      "id": 1,
      "name": "Binary Search",
      "category": "Searching",
      "description": "Efficiently search for an element in a sorted array by repeatedly dividing the search interval in half",
      "time_complexity": {
        "best": "O(1)",
        "average": "O(log n)",
        "worst": "O(log n)"
      },
      "space_complexity": "O(1)",
      "prerequisites": ["Array must be sorted"],
      "use_cases": ["Searching in sorted arrays", "Finding insertion point", "Range queries"],
      "implementations": {
        "python": "def binary_search(arr, target):\n    \"\"\"\n    Binary search implementation in Python\n    \"\"\"\n    left, right = 0, len(arr) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return -1  # Element not found\n\n# Example usage\narr = [1, 3, 5, 7, 9, 11, 13, 15]\ntarget = 7\nresult = binary_search(arr, target)\nprint(f\"Element found at index: {result}\")",
        "java": "public class BinarySearch {\n    public static int binarySearch(int[] arr, int target) {\n        int left = 0;\n        int right = arr.length - 1;\n        \n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            \n            if (arr[mid] == target) {\n                return mid;\n            } else if (arr[mid] < target) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n        \n        return -1; // Element not found\n    }\n    \n    // Example usage\n    public static void main(String[] args) {\n        int[] arr = {1, 3, 5, 7, 9, 11, 13, 15};\n        int target = 7;\n        int result = binarySearch(arr, target);\n        System.out.println(\"Element found at index: \" + result);\n    }\n}",
        "csharp": "public class BinarySearch\n{\n    public static int Search(int[] arr, int target)\n    {\n        int left = 0;\n        int right = arr.Length - 1;\n        \n        while (left <= right)\n        {\n            int mid = left + (right - left) / 2;\n            \n            if (arr[mid] == target)\n            {\n                return mid;\n            }\n            else if (arr[mid] < target)\n            {\n                left = mid + 1;\n            }\n            else\n            {\n                right = mid - 1;\n            }\n        }\n        \n        return -1; // Element not found\n    }\n    \n    // Example usage\n    static void Main(string[] args)\n    {\n        int[] arr = {1, 3, 5, 7, 9, 11, 13, 15};\n        int target = 7;\n        int result = Search(arr, target);\n        Console.WriteLine($\"Element found at index: {result}\");\n    }\n}"
      }
    },
    {
      "id": 2,
      "name": "Linear Search",
      "category": "Searching",
      "description": "A simple search algorithm that finds a target value within a list by checking each element sequentially",
      "time_complexity": {
        "best": "O(1)",
        "average": "O(n)",
        "worst": "O(n)"
      },
      "space_complexity": "O(1)",
      "prerequisites": ["None"],
      "use_cases": ["Searching in unsorted arrays", "Small datasets", "Finding all occurrences"],
      "implementations": {
        "python": "def linear_search(arr, target):\n    \"\"\"\n    Linear search implementation in Python\n    \"\"\"\n    for i in range(len(arr)):\n        if arr[i] == target:\n            return i\n    return -1  # Element not found\n\ndef linear_search_all(arr, target):\n    \"\"\"\n    Find all occurrences of target\n    \"\"\"\n    indices = []\n    for i in range(len(arr)):\n        if arr[i] == target:\n            indices.append(i)\n    return indices\n\n# Example usage\narr = [64, 34, 25, 12, 22, 11, 90, 25]\ntarget = 25\nresult = linear_search(arr, target)\nprint(f\"Element found at index: {result}\")\n\nall_indices = linear_search_all(arr, target)\nprint(f\"All occurrences at indices: {all_indices}\")",
        "java": "public class LinearSearch {\n    public static int linearSearch(int[] arr, int target) {\n        for (int i = 0; i < arr.length; i++) {\n            if (arr[i] == target) {\n                return i;\n            }\n        }\n        return -1; // Element not found\n    }\n    \n    public static int[] linearSearchAll(int[] arr, int target) {\n        java.util.List<Integer> indices = new java.util.ArrayList<>();\n        for (int i = 0; i < arr.length; i++) {\n            if (arr[i] == target) {\n                indices.add(i);\n            }\n        }\n        return indices.stream().mapToInt(i -> i).toArray();\n    }\n    \n    // Example usage\n    public static void main(String[] args) {\n        int[] arr = {64, 34, 25, 12, 22, 11, 90, 25};\n        int target = 25;\n        int result = linearSearch(arr, target);\n        System.out.println(\"Element found at index: \" + result);\n        \n        int[] allIndices = linearSearchAll(arr, target);\n        System.out.println(\"All occurrences at indices: \" + java.util.Arrays.toString(allIndices));\n    }\n}",
        "csharp": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic class LinearSearch\n{\n    public static int Search(int[] arr, int target)\n    {\n        for (int i = 0; i < arr.Length; i++)\n        {\n            if (arr[i] == target)\n            {\n                return i;\n            }\n        }\n        return -1; // Element not found\n    }\n    \n    public static int[] SearchAll(int[] arr, int target)\n    {\n        List<int> indices = new List<int>();\n        for (int i = 0; i < arr.Length; i++)\n        {\n            if (arr[i] == target)\n            {\n                indices.Add(i);\n            }\n        }\n        return indices.ToArray();\n    }\n    \n    // Example usage\n    static void Main(string[] args)\n    {\n        int[] arr = {64, 34, 25, 12, 22, 11, 90, 25};\n        int target = 25;\n        int result = Search(arr, target);\n        Console.WriteLine($\"Element found at index: {result}\");\n        \n        int[] allIndices = SearchAll(arr, target);\n        Console.WriteLine($\"All occurrences at indices: [{string.Join(\", \", allIndices)}]\");\n    }\n}"
      }
    },
    {
      "id": 3,
      "name": "Bubble Sort",
      "category": "Sorting",
      "description": "A simple sorting algorithm that repeatedly steps through the list, compares adjacent elements and swaps them if they are in the wrong order",
      "time_complexity": {
        "best": "O(n)",
        "average": "O(n²)",
        "worst": "O(n²)"
      },
      "space_complexity": "O(1)",
      "prerequisites": ["None"],
      "use_cases": ["Educational purposes", "Small datasets", "Nearly sorted arrays"],
      "implementations": {
        "python": "def bubble_sort(arr):\n    \"\"\"\n    Bubble sort implementation in Python\n    \"\"\"\n    n = len(arr)\n    \n    # Traverse through all array elements\n    for i in range(n):\n        # Flag to optimize - if no swapping occurs, array is sorted\n        swapped = False\n        \n        # Last i elements are already in place\n        for j in range(0, n - i - 1):\n            # Traverse the array from 0 to n-i-1\n            # Swap if the element found is greater than the next element\n            if arr[j] > arr[j + 1]:\n                arr[j], arr[j + 1] = arr[j + 1], arr[j]\n                swapped = True\n        \n        # If no two elements were swapped, array is sorted\n        if not swapped:\n            break\n    \n    return arr\n\n# Example usage\narr = [64, 34, 25, 12, 22, 11, 90]\nprint(f\"Original array: {arr}\")\nsorted_arr = bubble_sort(arr.copy())\nprint(f\"Sorted array: {sorted_arr}\")",
        "java": "public class BubbleSort {\n    public static void bubbleSort(int[] arr) {\n        int n = arr.length;\n        \n        for (int i = 0; i < n - 1; i++) {\n            boolean swapped = false;\n            \n            for (int j = 0; j < n - i - 1; j++) {\n                if (arr[j] > arr[j + 1]) {\n                    // Swap arr[j] and arr[j+1]\n                    int temp = arr[j];\n                    arr[j] = arr[j + 1];\n                    arr[j + 1] = temp;\n                    swapped = true;\n                }\n            }\n            \n            // If no two elements were swapped, array is sorted\n            if (!swapped) {\n                break;\n            }\n        }\n    }\n    \n    // Example usage\n    public static void main(String[] args) {\n        int[] arr = {64, 34, 25, 12, 22, 11, 90};\n        System.out.println(\"Original array: \" + java.util.Arrays.toString(arr));\n        \n        bubbleSort(arr);\n        System.out.println(\"Sorted array: \" + java.util.Arrays.toString(arr));\n    }\n}",
        "csharp": "using System;\n\npublic class BubbleSort\n{\n    public static void Sort(int[] arr)\n    {\n        int n = arr.Length;\n        \n        for (int i = 0; i < n - 1; i++)\n        {\n            bool swapped = false;\n            \n            for (int j = 0; j < n - i - 1; j++)\n            {\n                if (arr[j] > arr[j + 1])\n                {\n                    // Swap arr[j] and arr[j+1]\n                    int temp = arr[j];\n                    arr[j] = arr[j + 1];\n                    arr[j + 1] = temp;\n                    swapped = true;\n                }\n            }\n            \n            // If no two elements were swapped, array is sorted\n            if (!swapped)\n            {\n                break;\n            }\n        }\n    }\n    \n    // Example usage\n    static void Main(string[] args)\n    {\n        int[] arr = {64, 34, 25, 12, 22, 11, 90};\n        Console.WriteLine($\"Original array: [{string.Join(\", \", arr)}]\");\n        \n        Sort(arr);\n        Console.WriteLine($\"Sorted array: [{string.Join(\", \", arr)}]\");\n    }\n}"
      }
    },
    {
      "id": 4,
      "name": "Selection Sort",
      "category": "Sorting",
      "description": "A sorting algorithm that divides the input list into sorted and unsorted regions, repeatedly selecting the smallest element from the unsorted region",
      "time_complexity": {
        "best": "O(n²)",
        "average": "O(n²)",
        "worst": "O(n²)"
      },
      "space_complexity": "O(1)",
      "prerequisites": ["None"],
      "use_cases": ["Small datasets", "Memory-constrained environments", "When minimizing swaps is important"],
      "implementations": {
        "python": "def selection_sort(arr):\n    \"\"\"\n    Selection sort implementation in Python\n    \"\"\"\n    n = len(arr)\n    \n    # Traverse through all array elements\n    for i in range(n):\n        # Find the minimum element in remaining unsorted array\n        min_idx = i\n        for j in range(i + 1, n):\n            if arr[j] < arr[min_idx]:\n                min_idx = j\n        \n        # Swap the found minimum element with the first element\n        arr[i], arr[min_idx] = arr[min_idx], arr[i]\n    \n    return arr\n\ndef selection_sort_with_steps(arr):\n    \"\"\"\n    Selection sort with step-by-step visualization\n    \"\"\"\n    n = len(arr)\n    print(f\"Initial array: {arr}\")\n    \n    for i in range(n):\n        min_idx = i\n        for j in range(i + 1, n):\n            if arr[j] < arr[min_idx]:\n                min_idx = j\n        \n        arr[i], arr[min_idx] = arr[min_idx], arr[i]\n        print(f\"Step {i + 1}: {arr}\")\n    \n    return arr\n\n# Example usage\narr = [64, 25, 12, 22, 11]\nprint(f\"Original array: {arr}\")\nsorted_arr = selection_sort(arr.copy())\nprint(f\"Sorted array: {sorted_arr}\")",
        "java": "public class SelectionSort {\n    public static void selectionSort(int[] arr) {\n        int n = arr.length;\n        \n        // One by one move boundary of unsorted subarray\n        for (int i = 0; i < n - 1; i++) {\n            // Find the minimum element in unsorted array\n            int minIdx = i;\n            for (int j = i + 1; j < n; j++) {\n                if (arr[j] < arr[minIdx]) {\n                    minIdx = j;\n                }\n            }\n            \n            // Swap the found minimum element with the first element\n            int temp = arr[minIdx];\n            arr[minIdx] = arr[i];\n            arr[i] = temp;\n        }\n    }\n    \n    public static void selectionSortWithSteps(int[] arr) {\n        int n = arr.length;\n        System.out.println(\"Initial array: \" + java.util.Arrays.toString(arr));\n        \n        for (int i = 0; i < n - 1; i++) {\n            int minIdx = i;\n            for (int j = i + 1; j < n; j++) {\n                if (arr[j] < arr[minIdx]) {\n                    minIdx = j;\n                }\n            }\n            \n            int temp = arr[minIdx];\n            arr[minIdx] = arr[i];\n            arr[i] = temp;\n            \n            System.out.println(\"Step \" + (i + 1) + \": \" + java.util.Arrays.toString(arr));\n        }\n    }\n    \n    // Example usage\n    public static void main(String[] args) {\n        int[] arr = {64, 25, 12, 22, 11};\n        System.out.println(\"Original array: \" + java.util.Arrays.toString(arr));\n        \n        selectionSort(arr);\n        System.out.println(\"Sorted array: \" + java.util.Arrays.toString(arr));\n    }\n}",
        "csharp": "using System;\n\npublic class SelectionSort\n{\n    public static void Sort(int[] arr)\n    {\n        int n = arr.Length;\n        \n        // One by one move boundary of unsorted subarray\n        for (int i = 0; i < n - 1; i++)\n        {\n            // Find the minimum element in unsorted array\n            int minIdx = i;\n            for (int j = i + 1; j < n; j++)\n            {\n                if (arr[j] < arr[minIdx])\n                {\n                    minIdx = j;\n                }\n            }\n            \n            // Swap the found minimum element with the first element\n            int temp = arr[minIdx];\n            arr[minIdx] = arr[i];\n            arr[i] = temp;\n        }\n    }\n    \n    public static void SortWithSteps(int[] arr)\n    {\n        int n = arr.Length;\n        Console.WriteLine($\"Initial array: [{string.Join(\", \", arr)}]\");\n        \n        for (int i = 0; i < n - 1; i++)\n        {\n            int minIdx = i;\n            for (int j = i + 1; j < n; j++)\n            {\n                if (arr[j] < arr[minIdx])\n                {\n                    minIdx = j;\n                }\n            }\n            \n            int temp = arr[minIdx];\n            arr[minIdx] = arr[i];\n            arr[i] = temp;\n            \n            Console.WriteLine($\"Step {i + 1}: [{string.Join(\", \", arr)}]\");\n        }\n    }\n    \n    // Example usage\n    static void Main(string[] args)\n    {\n        int[] arr = {64, 25, 12, 22, 11};\n        Console.WriteLine($\"Original array: [{string.Join(\", \", arr)}]\");\n        \n        Sort(arr);\n        Console.WriteLine($\"Sorted array: [{string.Join(\", \", arr)}]\");\n    }\n}"
      }
    },
    {
      "id": 5,
      "name": "Insertion Sort",
      "category": "Sorting",
      "description": "A simple sorting algorithm that builds the final sorted array one item at a time, similar to sorting playing cards in your hands",
      "time_complexity": {
        "best": "O(n)",
        "average": "O(n²)",
        "worst": "O(n²)"
      },
      "space_complexity": "O(1)",
      "prerequisites": ["None"],
      "use_cases": ["Small datasets", "Nearly sorted arrays", "Online sorting", "Hybrid sorting algorithms"],
      "implementations": {
        "python": "def insertion_sort(arr):\n    \"\"\"\n    Insertion sort implementation in Python\n    \"\"\"\n    # Traverse from 1 to len(arr)\n    for i in range(1, len(arr)):\n        key = arr[i]\n        \n        # Move elements of arr[0..i-1], that are greater than key,\n        # to one position ahead of their current position\n        j = i - 1\n        while j >= 0 and arr[j] > key:\n            arr[j + 1] = arr[j]\n            j -= 1\n        \n        arr[j + 1] = key\n    \n    return arr\n\ndef insertion_sort_recursive(arr, n=None):\n    \"\"\"\n    Recursive implementation of insertion sort\n    \"\"\"\n    if n is None:\n        n = len(arr)\n    \n    # Base case\n    if n <= 1:\n        return\n    \n    # Sort first n-1 elements\n    insertion_sort_recursive(arr, n - 1)\n    \n    # Insert last element at its correct position\n    last = arr[n - 1]\n    j = n - 2\n    \n    while j >= 0 and arr[j] > last:\n        arr[j + 1] = arr[j]\n        j -= 1\n    \n    arr[j + 1] = last\n\n# Example usage\narr = [12, 11, 13, 5, 6]\nprint(f\"Original array: {arr}\")\nsorted_arr = insertion_sort(arr.copy())\nprint(f\"Sorted array: {sorted_arr}\")",
        "java": "public class InsertionSort {\n    public static void insertionSort(int[] arr) {\n        int n = arr.length;\n        \n        for (int i = 1; i < n; i++) {\n            int key = arr[i];\n            int j = i - 1;\n            \n            // Move elements of arr[0..i-1], that are greater than key,\n            // to one position ahead of their current position\n            while (j >= 0 && arr[j] > key) {\n                arr[j + 1] = arr[j];\n                j = j - 1;\n            }\n            arr[j + 1] = key;\n        }\n    }\n    \n    public static void insertionSortRecursive(int[] arr, int n) {\n        // Base case\n        if (n <= 1) {\n            return;\n        }\n        \n        // Sort first n-1 elements\n        insertionSortRecursive(arr, n - 1);\n        \n        // Insert last element at its correct position\n        int last = arr[n - 1];\n        int j = n - 2;\n        \n        while (j >= 0 && arr[j] > last) {\n            arr[j + 1] = arr[j];\n            j--;\n        }\n        arr[j + 1] = last;\n    }\n    \n    // Example usage\n    public static void main(String[] args) {\n        int[] arr = {12, 11, 13, 5, 6};\n        System.out.println(\"Original array: \" + java.util.Arrays.toString(arr));\n        \n        insertionSort(arr);\n        System.out.println(\"Sorted array: \" + java.util.Arrays.toString(arr));\n    }\n}",
        "csharp": "using System;\n\npublic class InsertionSort\n{\n    public static void Sort(int[] arr)\n    {\n        int n = arr.Length;\n        \n        for (int i = 1; i < n; i++)\n        {\n            int key = arr[i];\n            int j = i - 1;\n            \n            // Move elements of arr[0..i-1], that are greater than key,\n            // to one position ahead of their current position\n            while (j >= 0 && arr[j] > key)\n            {\n                arr[j + 1] = arr[j];\n                j = j - 1;\n            }\n            arr[j + 1] = key;\n        }\n    }\n    \n    public static void SortRecursive(int[] arr, int n)\n    {\n        // Base case\n        if (n <= 1)\n        {\n            return;\n        }\n        \n        // Sort first n-1 elements\n        SortRecursive(arr, n - 1);\n        \n        // Insert last element at its correct position\n        int last = arr[n - 1];\n        int j = n - 2;\n        \n        while (j >= 0 && arr[j] > last)\n        {\n            arr[j + 1] = arr[j];\n            j--;\n        }\n        arr[j + 1] = last;\n    }\n    \n    // Example usage\n    static void Main(string[] args)\n    {\n        int[] arr = {12, 11, 13, 5, 6};\n        Console.WriteLine($\"Original array: [{string.Join(\", \", arr)}]\");\n        \n        Sort(arr);\n        Console.WriteLine($\"Sorted array: [{string.Join(\", \", arr)}]\");\n    }\n}"
      }
    },
    {
      "id": 6,
      "name": "Merge Sort",
      "category": "Sorting",
      "description": "A divide-and-conquer algorithm that divides the array into halves, sorts them, and then merges them back together",
      "time_complexity": {
        "best": "O(n log n)",
        "average": "O(n log n)",
        "worst": "O(n log n)"
      },
      "space_complexity": "O(n)",
      "prerequisites": ["Understanding of recursion", "Divide and conquer concept"],
      "use_cases": ["Stable sorting", "Large datasets", "External sorting", "Linked list sorting"],
      "implementations": {
        "python": "def merge_sort(arr):\n    \"\"\"\n    Merge sort implementation in Python\n    \"\"\"\n    if len(arr) <= 1:\n        return arr\n    \n    # Divide the array into two halves\n    mid = len(arr) // 2\n    left_half = arr[:mid]\n    right_half = arr[mid:]\n    \n    # Recursively sort both halves\n    left_sorted = merge_sort(left_half)\n    right_sorted = merge_sort(right_half)\n    \n    # Merge the sorted halves\n    return merge(left_sorted, right_sorted)\n\ndef merge(left, right):\n    \"\"\"\n    Merge two sorted arrays\n    \"\"\"\n    result = []\n    i = j = 0\n    \n    # Compare elements and merge\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    # Add remaining elements\n    result.extend(left[i:])\n    result.extend(right[j:])\n    \n    return result\n\ndef merge_sort_inplace(arr, left=0, right=None):\n    \"\"\"\n    In-place merge sort implementation\n    \"\"\"\n    if right is None:\n        right = len(arr) - 1\n    \n    if left < right:\n        mid = (left + right) // 2\n        \n        # Sort first and second halves\n        merge_sort_inplace(arr, left, mid)\n        merge_sort_inplace(arr, mid + 1, right)\n        \n        # Merge the sorted halves\n        merge_inplace(arr, left, mid, right)\n\ndef merge_inplace(arr, left, mid, right):\n    \"\"\"\n    Merge function for in-place merge sort\n    \"\"\"\n    # Create temporary arrays\n    left_arr = arr[left:mid + 1]\n    right_arr = arr[mid + 1:right + 1]\n    \n    i = j = 0\n    k = left\n    \n    # Merge the temporary arrays back\n    while i < len(left_arr) and j < len(right_arr):\n        if left_arr[i] <= right_arr[j]:\n            arr[k] = left_arr[i]\n            i += 1\n        else:\n            arr[k] = right_arr[j]\n            j += 1\n        k += 1\n    \n    # Copy remaining elements\n    while i < len(left_arr):\n        arr[k] = left_arr[i]\n        i += 1\n        k += 1\n    \n    while j < len(right_arr):\n        arr[k] = right_arr[j]\n        j += 1\n        k += 1\n\n# Example usage\narr = [64, 34, 25, 12, 22, 11, 90]\nprint(f\"Original array: {arr}\")\nsorted_arr = merge_sort(arr)\nprint(f\"Sorted array: {sorted_arr}\")",
        "java": "public class MergeSort {\n    \n    public static void mergeSort(int[] arr) {\n        if (arr.length <= 1) {\n            return;\n        }\n        \n        mergeSortHelper(arr, 0, arr.length - 1);\n    }\n    \n    private static void mergeSortHelper(int[] arr, int left, int right) {\n        if (left < right) {\n            int mid = left + (right - left) / 2;\n            \n            // Sort first and second halves\n            mergeSortHelper(arr, left, mid);\n            mergeSortHelper(arr, mid + 1, right);\n            \n            // Merge the sorted halves\n            merge(arr, left, mid, right);\n        }\n    }\n    \n    private static void merge(int[] arr, int left, int mid, int right) {\n        // Calculate sizes of subarrays\n        int leftSize = mid - left + 1;\n        int rightSize = right - mid;\n        \n        // Create temporary arrays\n        int[] leftArr = new int[leftSize];\n        int[] rightArr = new int[rightSize];\n        \n        // Copy data to temporary arrays\n        System.arraycopy(arr, left, leftArr, 0, leftSize);\n        System.arraycopy(arr, mid + 1, rightArr, 0, rightSize);\n        \n        // Merge the temporary arrays\n        int i = 0, j = 0, k = left;\n        \n        while (i < leftSize && j < rightSize) {\n            if (leftArr[i] <= rightArr[j]) {\n                arr[k] = leftArr[i];\n                i++;\n            } else {\n                arr[k] = rightArr[j];\n                j++;\n            }\n            k++;\n        }\n        \n        // Copy remaining elements\n        while (i < leftSize) {\n            arr[k] = leftArr[i];\n            i++;\n            k++;\n        }\n        \n        while (j < rightSize) {\n            arr[k] = rightArr[j];\n            j++;\n            k++;\n        }\n    }\n    \n    // Alternative implementation returning new array\n    public static int[] mergeSortNew(int[] arr) {\n        if (arr.length <= 1) {\n            return arr.clone();\n        }\n        \n        int mid = arr.length / 2;\n        int[] left = new int[mid];\n        int[] right = new int[arr.length - mid];\n        \n        System.arraycopy(arr, 0, left, 0, mid);\n        System.arraycopy(arr, mid, right, 0, arr.length - mid);\n        \n        left = mergeSortNew(left);\n        right = mergeSortNew(right);\n        \n        return mergeArrays(left, right);\n    }\n    \n    private static int[] mergeArrays(int[] left, int[] right) {\n        int[] result = new int[left.length + right.length];\n        int i = 0, j = 0, k = 0;\n        \n        while (i < left.length && j < right.length) {\n            if (left[i] <= right[j]) {\n                result[k] = left[i];\n                i++;\n            } else {\n                result[k] = right[j];\n                j++;\n            }\n            k++;\n        }\n        \n        while (i < left.length) {\n            result[k] = left[i];\n            i++;\n            k++;\n        }\n        \n        while (j < right.length) {\n            result[k] = right[j];\n            j++;\n            k++;\n        }\n        \n        return result;\n    }\n    \n    // Example usage\n    public static void main(String[] args) {\n        int[] arr = {64, 34, 25, 12, 22, 11, 90};\n        System.out.println(\"Original array: \" + java.util.Arrays.toString(arr));\n        \n        mergeSort(arr);\n        System.out.println(\"Sorted array: \" + java.util.Arrays.toString(arr));\n    }\n}",
        "csharp": "using System;\n\npublic class MergeSort\n{\n    public static void Sort(int[] arr)\n    {\n        if (arr.Length <= 1)\n        {\n            return;\n        }\n        \n        MergeSortHelper(arr, 0, arr.Length - 1);\n    }\n    \n    private static void MergeSortHelper(int[] arr, int left, int right)\n    {\n        if (left < right)\n        {\n            int mid = left + (right - left) / 2;\n            \n            // Sort first and second halves\n            MergeSortHelper(arr, left, mid);\n            MergeSortHelper(arr, mid + 1, right);\n            \n            // Merge the sorted halves\n            Merge(arr, left, mid, right);\n        }\n    }\n    \n    private static void Merge(int[] arr, int left, int mid, int right)\n    {\n        // Calculate sizes of subarrays\n        int leftSize = mid - left + 1;\n        int rightSize = right - mid;\n        \n        // Create temporary arrays\n        int[] leftArr = new int[leftSize];\n        int[] rightArr = new int[rightSize];\n        \n        // Copy data to temporary arrays\n        Array.Copy(arr, left, leftArr, 0, leftSize);\n        Array.Copy(arr, mid + 1, rightArr, 0, rightSize);\n        \n        // Merge the temporary arrays\n        int i = 0, j = 0, k = left;\n        \n        while (i < leftSize && j < rightSize)\n        {\n            if (leftArr[i] <= rightArr[j])\n            {\n                arr[k] = leftArr[i];\n                i++;\n            }\n            else\n            {\n                arr[k] = rightArr[j];\n                j++;\n            }\n            k++;\n        }\n        \n        // Copy remaining elements\n        while (i < leftSize)\n        {\n            arr[k] = leftArr[i];\n            i++;\n            k++;\n        }\n        \n        while (j < rightSize)\n        {\n            arr[k] = rightArr[j];\n            j++;\n            k++;\n        }\n    }\n    \n    // Alternative implementation returning new array\n    public static int[] SortNew(int[] arr)\n    {\n        if (arr.Length <= 1)\n        {\n            return (int[])arr.Clone();\n        }\n        \n        int mid = arr.Length / 2;\n        int[] left = new int[mid];\n        int[] right = new int[arr.Length - mid];\n        \n        Array.Copy(arr, 0, left, 0, mid);\n        Array.Copy(arr, mid, right, 0, arr.Length - mid);\n        \n        left = SortNew(left);\n        right = SortNew(right);\n        \n        return MergeArrays(left, right);\n    }\n    \n    private static int[] MergeArrays(int[] left, int[] right)\n    {\n        int[] result = new int[left.Length + right.Length];\n        int i = 0, j = 0, k = 0;\n        \n        while (i < left.Length && j < right.Length)\n        {\n            if (left[i] <= right[j])\n            {\n                result[k] = left[i];\n                i++;\n            }\n            else\n            {\n                result[k] = right[j];\n                j++;\n            }\n            k++;\n        }\n        \n        while (i < left.Length)\n        {\n            result[k] = left[i];\n            i++;\n            k++;\n        }\n        \n        while (j < right.Length)\n        {\n            result[k] = right[j];\n            j++;\n            k++;\n        }\n        \n        return result;\n    }\n    \n    // Example usage\n    static void Main(string[] args)\n    {\n        int[] arr = {64, 34, 25, 12, 22, 11, 90};\n        Console.WriteLine($\"Original array: [{string.Join(\", \", arr)}]\");\n        \n        Sort(arr);\n        Console.WriteLine($\"Sorted array: [{string.Join(\", \", arr)}]\");\n    }\n}"
      }
    },
    {
      "id": 7,
      "name": "Quick Sort",
      "category": "Sorting",
      "description": "A divide-and-conquer algorithm that picks a pivot element and partitions the array around it",
      "time_complexity": {
        "best": "O(n log n)",
        "average": "O(n log n)",
        "worst": "O(n²)"
      },
      "space_complexity": "O(log n)",
      "prerequisites": ["Understanding of recursion", "Partitioning concept"],
      "use_cases": ["General purpose sorting", "In-place sorting", "Cache-efficient sorting", "Average case performance"],
      "implementations": {
        "python": "def quick_sort(arr):\n    \"\"\"\n    Quick sort implementation in Python\n    \"\"\"\n    if len(arr) <= 1:\n        return arr\n    \n    pivot = arr[len(arr) // 2]\n    left = [x for x in arr if x < pivot]\n    middle = [x for x in arr if x == pivot]\n    right = [x for x in arr if x > pivot]\n    \n    return quick_sort(left) + middle + quick_sort(right)\n\ndef quick_sort_inplace(arr, low=0, high=None):\n    \"\"\"\n    In-place quick sort implementation\n    \"\"\"\n    if high is None:\n        high = len(arr) - 1\n    \n    if low < high:\n        # Partition the array and get pivot index\n        pivot_index = partition(arr, low, high)\n        \n        # Recursively sort elements before and after partition\n        quick_sort_inplace(arr, low, pivot_index - 1)\n        quick_sort_inplace(arr, pivot_index + 1, high)\n\ndef partition(arr, low, high):\n    \"\"\"\n    Lomuto partition scheme\n    \"\"\"\n    # Choose the rightmost element as pivot\n    pivot = arr[high]\n    \n    # Index of smaller element\n    i = low - 1\n    \n    for j in range(low, high):\n        # If current element is smaller than or equal to pivot\n        if arr[j] <= pivot:\n            i += 1\n            arr[i], arr[j] = arr[j], arr[i]\n    \n    # Place pivot in correct position\n    arr[i + 1], arr[high] = arr[high], arr[i + 1]\n    return i + 1\n\ndef partition_hoare(arr, low, high):\n    \"\"\"\n    Hoare partition scheme (alternative)\n    \"\"\"\n    pivot = arr[low]\n    i = low - 1\n    j = high + 1\n    \n    while True:\n        # Find element on left that should be on right\n        i += 1\n        while arr[i] < pivot:\n            i += 1\n        \n        # Find element on right that should be on left\n        j -= 1\n        while arr[j] > pivot:\n            j -= 1\n        \n        # If elements crossed, partitioning is done\n        if i >= j:\n            return j\n        \n        # Swap elements\n        arr[i], arr[j] = arr[j], arr[i]\n\ndef quick_sort_random(arr, low=0, high=None):\n    \"\"\"\n    Quick sort with random pivot selection\n    \"\"\"\n    import random\n    \n    if high is None:\n        high = len(arr) - 1\n    \n    if low < high:\n        # Randomly choose pivot and swap with last element\n        random_index = random.randint(low, high)\n        arr[random_index], arr[high] = arr[high], arr[random_index]\n        \n        pivot_index = partition(arr, low, high)\n        \n        quick_sort_random(arr, low, pivot_index - 1)\n        quick_sort_random(arr, pivot_index + 1, high)\n\n# Example usage\narr = [64, 34, 25, 12, 22, 11, 90]\nprint(f\"Original array: {arr}\")\nsorted_arr = quick_sort(arr)\nprint(f\"Sorted array: {sorted_arr}\")\n\n# In-place sorting\narr2 = [64, 34, 25, 12, 22, 11, 90]\nquick_sort_inplace(arr2)\nprint(f\"In-place sorted: {arr2}\")",
        "java": "import java.util.Random;\n\npublic class QuickSort {\n    \n    public static void quickSort(int[] arr) {\n        if (arr.length <= 1) {\n            return;\n        }\n        quickSortHelper(arr, 0, arr.length - 1);\n    }\n    \n    private static void quickSortHelper(int[] arr, int low, int high) {\n        if (low < high) {\n            // Partition the array and get pivot index\n            int pivotIndex = partition(arr, low, high);\n            \n            // Recursively sort elements before and after partition\n            quickSortHelper(arr, low, pivotIndex - 1);\n            quickSortHelper(arr, pivotIndex + 1, high);\n        }\n    }\n    \n    private static int partition(int[] arr, int low, int high) {\n        // Choose the rightmost element as pivot\n        int pivot = arr[high];\n        \n        // Index of smaller element\n        int i = low - 1;\n        \n        for (int j = low; j < high; j++) {\n            // If current element is smaller than or equal to pivot\n            if (arr[j] <= pivot) {\n                i++;\n                swap(arr, i, j);\n            }\n        }\n        \n        // Place pivot in correct position\n        swap(arr, i + 1, high);\n        return i + 1;\n    }\n    \n    private static int partitionHoare(int[] arr, int low, int high) {\n        int pivot = arr[low];\n        int i = low - 1;\n        int j = high + 1;\n        \n        while (true) {\n            // Find element on left that should be on right\n            do {\n                i++;\n            } while (arr[i] < pivot);\n            \n            // Find element on right that should be on left\n            do {\n                j--;\n            } while (arr[j] > pivot);\n            \n            // If elements crossed, partitioning is done\n            if (i >= j) {\n                return j;\n            }\n            \n            // Swap elements\n            swap(arr, i, j);\n        }\n    }\n    \n    public static void quickSortRandom(int[] arr) {\n        quickSortRandomHelper(arr, 0, arr.length - 1);\n    }\n    \n    private static void quickSortRandomHelper(int[] arr, int low, int high) {\n        if (low < high) {\n            // Randomly choose pivot and swap with last element\n            Random rand = new Random();\n            int randomIndex = rand.nextInt(high - low + 1) + low;\n            swap(arr, randomIndex, high);\n            \n            int pivotIndex = partition(arr, low, high);\n            \n            quickSortRandomHelper(arr, low, pivotIndex - 1);\n            quickSortRandomHelper(arr, pivotIndex + 1, high);\n        }\n    }\n    \n    private static void swap(int[] arr, int i, int j) {\n        int temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }\n    \n    // Three-way partitioning for arrays with many duplicates\n    public static void quickSort3Way(int[] arr, int low, int high) {\n        if (low >= high) return;\n        \n        int lt = low, gt = high;\n        int pivot = arr[low];\n        int i = low + 1;\n        \n        while (i <= gt) {\n            if (arr[i] < pivot) {\n                swap(arr, lt++, i++);\n            } else if (arr[i] > pivot) {\n                swap(arr, i, gt--);\n            } else {\n                i++;\n            }\n        }\n        \n        quickSort3Way(arr, low, lt - 1);\n        quickSort3Way(arr, gt + 1, high);\n    }\n    \n    // Example usage\n    public static void main(String[] args) {\n        int[] arr = {64, 34, 25, 12, 22, 11, 90};\n        System.out.println(\"Original array: \" + java.util.Arrays.toString(arr));\n        \n        quickSort(arr);\n        System.out.println(\"Sorted array: \" + java.util.Arrays.toString(arr));\n    }\n}",
        "csharp": "using System;\n\npublic class QuickSort\n{\n    public static void Sort(int[] arr)\n    {\n        if (arr.Length <= 1)\n        {\n            return;\n        }\n        QuickSortHelper(arr, 0, arr.Length - 1);\n    }\n    \n    private static void QuickSortHelper(int[] arr, int low, int high)\n    {\n        if (low < high)\n        {\n            // Partition the array and get pivot index\n            int pivotIndex = Partition(arr, low, high);\n            \n            // Recursively sort elements before and after partition\n            QuickSortHelper(arr, low, pivotIndex - 1);\n            QuickSortHelper(arr, pivotIndex + 1, high);\n        }\n    }\n    \n    private static int Partition(int[] arr, int low, int high)\n    {\n        // Choose the rightmost element as pivot\n        int pivot = arr[high];\n        \n        // Index of smaller element\n        int i = low - 1;\n        \n        for (int j = low; j < high; j++)\n        {\n            // If current element is smaller than or equal to pivot\n            if (arr[j] <= pivot)\n            {\n                i++;\n                Swap(arr, i, j);\n            }\n        }\n        \n        // Place pivot in correct position\n        Swap(arr, i + 1, high);\n        return i + 1;\n    }\n    \n    private static int PartitionHoare(int[] arr, int low, int high)\n    {\n        int pivot = arr[low];\n        int i = low - 1;\n        int j = high + 1;\n        \n        while (true)\n        {\n            // Find element on left that should be on right\n            do\n            {\n                i++;\n            } while (arr[i] < pivot);\n            \n            // Find element on right that should be on left\n            do\n            {\n                j--;\n            } while (arr[j] > pivot);\n            \n            // If elements crossed, partitioning is done\n            if (i >= j)\n            {\n                return j;\n            }\n            \n            // Swap elements\n            Swap(arr, i, j);\n        }\n    }\n    \n    public static void SortRandom(int[] arr)\n    {\n        QuickSortRandomHelper(arr, 0, arr.Length - 1);\n    }\n    \n    private static void QuickSortRandomHelper(int[] arr, int low, int high)\n    {\n        if (low < high)\n        {\n            // Randomly choose pivot and swap with last element\n            Random rand = new Random();\n            int randomIndex = rand.Next(low, high + 1);\n            Swap(arr, randomIndex, high);\n            \n            int pivotIndex = Partition(arr, low, high);\n            \n            QuickSortRandomHelper(arr, low, pivotIndex - 1);\n            QuickSortRandomHelper(arr, pivotIndex + 1, high);\n        }\n    }\n    \n    private static void Swap(int[] arr, int i, int j)\n    {\n        int temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }\n    \n    // Three-way partitioning for arrays with many duplicates\n    public static void Sort3Way(int[] arr, int low, int high)\n    {\n        if (low >= high) return;\n        \n        int lt = low, gt = high;\n        int pivot = arr[low];\n        int i = low + 1;\n        \n        while (i <= gt)\n        {\n            if (arr[i] < pivot)\n            {\n                Swap(arr, lt++, i++);\n            }\n            else if (arr[i] > pivot)\n            {\n                Swap(arr, i, gt--);\n            }\n            else\n            {\n                i++;\n            }\n        }\n        \n        Sort3Way(arr, low, lt - 1);\n        Sort3Way(arr, gt + 1, high);\n    }\n    \n    // Example usage\n    static void Main(string[] args)\n    {\n        int[] arr = {64, 34, 25, 12, 22, 11, 90};\n        Console.WriteLine($\"Original array: [{string.Join(\", \", arr)}]\");\n        \n        Sort(arr);\n        Console.WriteLine($\"Sorted array: [{string.Join(\", \", arr)}]\");\n    }\n}"
      }
    },
    {
      "id": 9,
      "name": "Breadth-First Search (BFS)",
      "category": "Graph",
      "description": "A graph traversal algorithm that explores all vertices at the current depth before moving to vertices at the next depth level",
      "time_complexity": {
        "best": "O(V + E)",
        "average": "O(V + E)",
        "worst": "O(V + E)"
      },
      "space_complexity": "O(V)",
      "prerequisites": ["Graph representation", "Queue data structure"],
      "use_cases": ["Shortest path in unweighted graphs", "Level-order traversal", "Connected components", "Bipartite graph detection"],
      "implementations": {
        "python": "# Python BFS Implementation\nfrom collections import deque, defaultdict\n\nclass Graph:\n    def __init__(self, directed=False):\n        self.graph = defaultdict(list)\n        self.directed = directed\n    \n    def add_edge(self, u, v):\n        self.graph[u].append(v)\n        if not self.directed:\n            self.graph[v].append(u)\n    \n    def bfs(self, start):\n        \"\"\"BFS traversal from start vertex\"\"\"\n        visited = set()\n        queue = deque([start])\n        result = []\n        \n        visited.add(start)\n        \n        while queue:\n            vertex = queue.popleft()\n            result.append(vertex)\n            \n            # Add all unvisited neighbors to queue\n            for neighbor in self.graph[vertex]:\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    queue.append(neighbor)\n        \n        return result\n    \n    def bfs_shortest_path(self, start, target):\n        \"\"\"Find shortest path between start and target\"\"\"\n        if start == target:\n            return [start]\n        \n        visited = set([start])\n        queue = deque([(start, [start])])\n        \n        while queue:\n            vertex, path = queue.popleft()\n            \n            for neighbor in self.graph[vertex]:\n                if neighbor == target:\n                    return path + [neighbor]\n                \n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    queue.append((neighbor, path + [neighbor]))\n        \n        return None  # No path found\n    \n    def bfs_level_order(self, start):\n        \"\"\"BFS with level information\"\"\"\n        visited = set([start])\n        queue = deque([(start, 0)])\n        levels = {}\n        \n        while queue:\n            vertex, level = queue.popleft()\n            \n            if level not in levels:\n                levels[level] = []\n            levels[level].append(vertex)\n            \n            for neighbor in self.graph[vertex]:\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    queue.append((neighbor, level + 1))\n        \n        return levels\n    \n    def is_bipartite(self):\n        \"\"\"Check if graph is bipartite using BFS\"\"\"\n        color = {}\n        \n        for start in self.graph:\n            if start not in color:\n                queue = deque([start])\n                color[start] = 0\n                \n                while queue:\n                    vertex = queue.popleft()\n                    \n                    for neighbor in self.graph[vertex]:\n                        if neighbor not in color:\n                            color[neighbor] = 1 - color[vertex]\n                            queue.append(neighbor)\n                        elif color[neighbor] == color[vertex]:\n                            return False\n        \n        return True\n\n# Example usage\ng = Graph()\ng.add_edge(0, 1)\ng.add_edge(0, 2)\ng.add_edge(1, 3)\ng.add_edge(2, 4)\ng.add_edge(3, 4)\n\nprint(\"BFS Traversal:\", g.bfs(0))\nprint(\"Shortest path from 0 to 4:\", g.bfs_shortest_path(0, 4))\nprint(\"Level order from 0:\", g.bfs_level_order(0))\nprint(\"Is bipartite:\", g.is_bipartite())",
        "java": "// Java BFS Implementation\nimport java.util.*;\n\npublic class Graph {\n    private Map<Integer, List<Integer>> adjacencyList;\n    private boolean directed;\n    \n    public Graph(boolean directed) {\n        this.adjacencyList = new HashMap<>();\n        this.directed = directed;\n    }\n    \n    public Graph() {\n        this(false);\n    }\n    \n    public void addEdge(int u, int v) {\n        adjacencyList.computeIfAbsent(u, k -> new ArrayList<>()).add(v);\n        if (!directed) {\n            adjacencyList.computeIfAbsent(v, k -> new ArrayList<>()).add(u);\n        }\n    }\n    \n    public List<Integer> bfs(int start) {\n        Set<Integer> visited = new HashSet<>();\n        Queue<Integer> queue = new LinkedList<>();\n        List<Integer> result = new ArrayList<>();\n        \n        visited.add(start);\n        queue.offer(start);\n        \n        while (!queue.isEmpty()) {\n            int vertex = queue.poll();\n            result.add(vertex);\n            \n            List<Integer> neighbors = adjacencyList.getOrDefault(vertex, new ArrayList<>());\n            for (int neighbor : neighbors) {\n                if (!visited.contains(neighbor)) {\n                    visited.add(neighbor);\n                    queue.offer(neighbor);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \n    public List<Integer> bfsShortestPath(int start, int target) {\n        if (start == target) {\n            return Arrays.asList(start);\n        }\n        \n        Set<Integer> visited = new HashSet<>();\n        Queue<List<Integer>> queue = new LinkedList<>();\n        \n        visited.add(start);\n        queue.offer(Arrays.asList(start));\n        \n        while (!queue.isEmpty()) {\n            List<Integer> path = queue.poll();\n            int vertex = path.get(path.size() - 1);\n            \n            List<Integer> neighbors = adjacencyList.getOrDefault(vertex, new ArrayList<>());\n            for (int neighbor : neighbors) {\n                if (neighbor == target) {\n                    List<Integer> newPath = new ArrayList<>(path);\n                    newPath.add(neighbor);\n                    return newPath;\n                }\n                \n                if (!visited.contains(neighbor)) {\n                    visited.add(neighbor);\n                    List<Integer> newPath = new ArrayList<>(path);\n                    newPath.add(neighbor);\n                    queue.offer(newPath);\n                }\n            }\n        }\n        \n        return null; // No path found\n    }\n    \n    public Map<Integer, List<Integer>> bfsLevelOrder(int start) {\n        Set<Integer> visited = new HashSet<>();\n        Queue<int[]> queue = new LinkedList<>();\n        Map<Integer, List<Integer>> levels = new HashMap<>();\n        \n        visited.add(start);\n        queue.offer(new int[]{start, 0});\n        \n        while (!queue.isEmpty()) {\n            int[] current = queue.poll();\n            int vertex = current[0];\n            int level = current[1];\n            \n            levels.computeIfAbsent(level, k -> new ArrayList<>()).add(vertex);\n            \n            List<Integer> neighbors = adjacencyList.getOrDefault(vertex, new ArrayList<>());\n            for (int neighbor : neighbors) {\n                if (!visited.contains(neighbor)) {\n                    visited.add(neighbor);\n                    queue.offer(new int[]{neighbor, level + 1});\n                }\n            }\n        }\n        \n        return levels;\n    }\n    \n    public boolean isBipartite() {\n        Map<Integer, Integer> color = new HashMap<>();\n        \n        for (int start : adjacencyList.keySet()) {\n            if (!color.containsKey(start)) {\n                Queue<Integer> queue = new LinkedList<>();\n                queue.offer(start);\n                color.put(start, 0);\n                \n                while (!queue.isEmpty()) {\n                    int vertex = queue.poll();\n                    \n                    List<Integer> neighbors = adjacencyList.getOrDefault(vertex, new ArrayList<>());\n                    for (int neighbor : neighbors) {\n                        if (!color.containsKey(neighbor)) {\n                            color.put(neighbor, 1 - color.get(vertex));\n                            queue.offer(neighbor);\n                        } else if (color.get(neighbor).equals(color.get(vertex))) {\n                            return false;\n                        }\n                    }\n                }\n            }\n        }\n        \n        return true;\n    }\n    \n    // Example usage\n    public static void main(String[] args) {\n        Graph g = new Graph();\n        g.addEdge(0, 1);\n        g.addEdge(0, 2);\n        g.addEdge(1, 3);\n        g.addEdge(2, 4);\n        g.addEdge(3, 4);\n        \n        System.out.println(\"BFS Traversal: \" + g.bfs(0));\n        System.out.println(\"Shortest path from 0 to 4: \" + g.bfsShortestPath(0, 4));\n        System.out.println(\"Level order from 0: \" + g.bfsLevelOrder(0));\n        System.out.println(\"Is bipartite: \" + g.isBipartite());\n    }\n}",
        "csharp": "// C# BFS Implementation\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic class Graph\n{\n    private Dictionary<int, List<int>> adjacencyList;\n    private bool directed;\n    \n    public Graph(bool directed = false)\n    {\n        this.adjacencyList = new Dictionary<int, List<int>>();\n        this.directed = directed;\n    }\n    \n    public void AddEdge(int u, int v)\n    {\n        if (!adjacencyList.ContainsKey(u))\n            adjacencyList[u] = new List<int>();\n        adjacencyList[u].Add(v);\n        \n        if (!directed)\n        {\n            if (!adjacencyList.ContainsKey(v))\n                adjacencyList[v] = new List<int>();\n            adjacencyList[v].Add(u);\n        }\n    }\n    \n    public List<int> BFS(int start)\n    {\n        HashSet<int> visited = new HashSet<int>();\n        Queue<int> queue = new Queue<int>();\n        List<int> result = new List<int>();\n        \n        visited.Add(start);\n        queue.Enqueue(start);\n        \n        while (queue.Count > 0)\n        {\n            int vertex = queue.Dequeue();\n            result.Add(vertex);\n            \n            if (adjacencyList.ContainsKey(vertex))\n            {\n                foreach (int neighbor in adjacencyList[vertex])\n                {\n                    if (!visited.Contains(neighbor))\n                    {\n                        visited.Add(neighbor);\n                        queue.Enqueue(neighbor);\n                    }\n                }\n            }\n        }\n        \n        return result;\n    }\n    \n    public List<int> BfsShortestPath(int start, int target)\n    {\n        if (start == target)\n        {\n            return new List<int> { start };\n        }\n        \n        HashSet<int> visited = new HashSet<int>();\n        Queue<List<int>> queue = new Queue<List<int>>();\n        \n        visited.Add(start);\n        queue.Enqueue(new List<int> { start });\n        \n        while (queue.Count > 0)\n        {\n            List<int> path = queue.Dequeue();\n            int vertex = path.Last();\n            \n            if (adjacencyList.ContainsKey(vertex))\n            {\n                foreach (int neighbor in adjacencyList[vertex])\n                {\n                    if (neighbor == target)\n                    {\n                        List<int> newPath = new List<int>(path);\n                        newPath.Add(neighbor);\n                        return newPath;\n                    }\n                    \n                    if (!visited.Contains(neighbor))\n                    {\n                        visited.Add(neighbor);\n                        List<int> newPath = new List<int>(path);\n                        newPath.Add(neighbor);\n                        queue.Enqueue(newPath);\n                    }\n                }\n            }\n        }\n        \n        return null; // No path found\n    }\n    \n    public Dictionary<int, List<int>> BfsLevelOrder(int start)\n    {\n        HashSet<int> visited = new HashSet<int>();\n        Queue<(int vertex, int level)> queue = new Queue<(int, int)>();\n        Dictionary<int, List<int>> levels = new Dictionary<int, List<int>>();\n        \n        visited.Add(start);\n        queue.Enqueue((start, 0));\n        \n        while (queue.Count > 0)\n        {\n            var (vertex, level) = queue.Dequeue();\n            \n            if (!levels.ContainsKey(level))\n                levels[level] = new List<int>();\n            levels[level].Add(vertex);\n            \n            if (adjacencyList.ContainsKey(vertex))\n            {\n                foreach (int neighbor in adjacencyList[vertex])\n                {\n                    if (!visited.Contains(neighbor))\n                    {\n                        visited.Add(neighbor);\n                        queue.Enqueue((neighbor, level + 1));\n                    }\n                }\n            }\n        }\n        \n        return levels;\n    }\n    \n    public bool IsBipartite()\n    {\n        Dictionary<int, int> color = new Dictionary<int, int>();\n        \n        foreach (int start in adjacencyList.Keys)\n        {\n            if (!color.ContainsKey(start))\n            {\n                Queue<int> queue = new Queue<int>();\n                queue.Enqueue(start);\n                color[start] = 0;\n                \n                while (queue.Count > 0)\n                {\n                    int vertex = queue.Dequeue();\n                    \n                    if (adjacencyList.ContainsKey(vertex))\n                    {\n                        foreach (int neighbor in adjacencyList[vertex])\n                        {\n                            if (!color.ContainsKey(neighbor))\n                            {\n                                color[neighbor] = 1 - color[vertex];\n                                queue.Enqueue(neighbor);\n                            }\n                            else if (color[neighbor] == color[vertex])\n                            {\n                                return false;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        \n        return true;\n    }\n    \n    // Example usage\n    static void Main(string[] args)\n    {\n        Graph g = new Graph();\n        g.AddEdge(0, 1);\n        g.AddEdge(0, 2);\n        g.AddEdge(1, 3);\n        g.AddEdge(2, 4);\n        g.AddEdge(3, 4);\n        \n        Console.WriteLine($\"BFS Traversal: [{string.Join(\", \", g.BFS(0))}]\");\n        Console.WriteLine($\"Shortest path from 0 to 4: [{string.Join(\", \", g.BfsShortestPath(0, 4))}]\");\n        Console.WriteLine($\"Level order from 0: {string.Join(\", \", g.BfsLevelOrder(0).Select(kvp => $\"Level {kvp.Key}: [{string.Join(\", \", kvp.Value)}]\"))}\");\n        Console.WriteLine($\"Is bipartite: {g.IsBipartite()}\");\n    }\n}"
      }
    },
    {
      "id": 10,
      "name": "Dijkstra's Algorithm",
      "category": "Graph",
      "description": "A graph algorithm that finds the shortest paths from a source vertex to all other vertices in a weighted graph with non-negative edge weights",
      "time_complexity": {
        "best": "O((V + E) log V)",
        "average": "O((V + E) log V)",
        "worst": "O((V + E) log V)"
      },
      "space_complexity": "O(V)",
      "prerequisites": ["Graph representation", "Priority queue/heap", "Weighted graphs"],
      "use_cases": ["GPS navigation systems", "Network routing protocols", "Social network analysis", "Game pathfinding"],
      "implementations": {
        "python": "# Python Dijkstra's Algorithm Implementation\nimport heapq\nfrom collections import defaultdict\nimport math\n\nclass WeightedGraph:\n    def __init__(self, directed=True):\n        self.graph = defaultdict(list)\n        self.directed = directed\n    \n    def add_edge(self, u, v, weight):\n        \"\"\"Add weighted edge to the graph\"\"\"\n        self.graph[u].append((v, weight))\n        if not self.directed:\n            self.graph[v].append((u, weight))\n    \n    def dijkstra(self, start):\n        \"\"\"Find shortest paths from start to all other vertices\"\"\"\n        # Initialize distances\n        distances = defaultdict(lambda: math.inf)\n        distances[start] = 0\n        \n        # Priority queue: (distance, vertex)\n        pq = [(0, start)]\n        visited = set()\n        previous = {}\n        \n        while pq:\n            current_dist, current_vertex = heapq.heappop(pq)\n            \n            if current_vertex in visited:\n                continue\n            \n            visited.add(current_vertex)\n            \n            # Check all neighbors\n            for neighbor, weight in self.graph[current_vertex]:\n                if neighbor in visited:\n                    continue\n                \n                new_dist = current_dist + weight\n                \n                if new_dist < distances[neighbor]:\n                    distances[neighbor] = new_dist\n                    previous[neighbor] = current_vertex\n                    heapq.heappush(pq, (new_dist, neighbor))\n        \n        return dict(distances), previous\n    \n    def shortest_path(self, start, end):\n        \"\"\"Find shortest path between start and end vertices\"\"\"\n        distances, previous = self.dijkstra(start)\n        \n        if end not in distances or distances[end] == math.inf:\n            return None, math.inf\n        \n        # Reconstruct path\n        path = []\n        current = end\n        \n        while current is not None:\n            path.append(current)\n            current = previous.get(current)\n        \n        path.reverse()\n        return path, distances[end]\n    \n    def shortest_paths_with_details(self, start):\n        \"\"\"Get detailed shortest path information\"\"\"\n        distances, previous = self.dijkstra(start)\n        \n        result = {}\n        for vertex in distances:\n            if distances[vertex] != math.inf:\n                # Reconstruct path\n                path = []\n                current = vertex\n                \n                while current is not None:\n                    path.append(current)\n                    current = previous.get(current)\n                \n                path.reverse()\n                \n                result[vertex] = {\n                    'distance': distances[vertex],\n                    'path': path\n                }\n        \n        return result\n\n# Alternative implementation with path tracking\ndef dijkstra_with_path(graph, start, end=None):\n    \"\"\"Dijkstra's algorithm with explicit path tracking\"\"\"\n    distances = {vertex: math.inf for vertex in graph}\n    distances[start] = 0\n    \n    pq = [(0, start, [start])]\n    visited = set()\n    \n    while pq:\n        current_dist, current_vertex, path = heapq.heappop(pq)\n        \n        if current_vertex in visited:\n            continue\n        \n        visited.add(current_vertex)\n        \n        # If we're looking for a specific end vertex\n        if end and current_vertex == end:\n            return current_dist, path\n        \n        # Check all neighbors\n        for neighbor, weight in graph.get(current_vertex, []):\n            if neighbor in visited:\n                continue\n            \n            new_dist = current_dist + weight\n            \n            if new_dist < distances[neighbor]:\n                distances[neighbor] = new_dist\n                new_path = path + [neighbor]\n                heapq.heappush(pq, (new_dist, neighbor, new_path))\n    \n    if end:\n        return distances.get(end, math.inf), None\n    return distances\n\n# Example usage\nif __name__ == \"__main__\":\n    # Create weighted graph\n    g = WeightedGraph(directed=False)\n    \n    # Add edges (vertex1, vertex2, weight)\n    edges = [\n        ('A', 'B', 4),\n        ('A', 'C', 2),\n        ('B', 'C', 1),\n        ('B', 'D', 5),\n        ('C', 'D', 8),\n        ('C', 'E', 10),\n        ('D', 'E', 2)\n    ]\n    \n    for u, v, w in edges:\n        g.add_edge(u, v, w)\n    \n    # Find shortest paths from 'A'\n    distances, previous = g.dijkstra('A')\n    print(\"Shortest distances from A:\", dict(distances))\n    \n    # Find shortest path from A to E\n    path, distance = g.shortest_path('A', 'E')\n    print(f\"Shortest path from A to E: {path} (distance: {distance})\")\n    \n    # Get all shortest paths from A\n    all_paths = g.shortest_paths_with_details('A')\n    for vertex, info in all_paths.items():\n        print(f\"To {vertex}: distance={info['distance']}, path={info['path']}\")",
        "java": "// Java Dijkstra's Algorithm Implementation\nimport java.util.*;\n\npublic class WeightedGraph {\n    private Map<String, List<Edge>> adjacencyList;\n    private boolean directed;\n    \n    public WeightedGraph(boolean directed) {\n        this.adjacencyList = new HashMap<>();\n        this.directed = directed;\n    }\n    \n    public WeightedGraph() {\n        this(true);\n    }\n    \n    static class Edge {\n        String destination;\n        int weight;\n        \n        Edge(String destination, int weight) {\n            this.destination = destination;\n            this.weight = weight;\n        }\n    }\n    \n    static class Node implements Comparable<Node> {\n        String vertex;\n        int distance;\n        \n        Node(String vertex, int distance) {\n            this.vertex = vertex;\n            this.distance = distance;\n        }\n        \n        @Override\n        public int compareTo(Node other) {\n            return Integer.compare(this.distance, other.distance);\n        }\n    }\n    \n    public void addEdge(String u, String v, int weight) {\n        adjacencyList.computeIfAbsent(u, k -> new ArrayList<>()).add(new Edge(v, weight));\n        if (!directed) {\n            adjacencyList.computeIfAbsent(v, k -> new ArrayList<>()).add(new Edge(u, weight));\n        }\n    }\n    \n    public Map<String, Integer> dijkstra(String start) {\n        Map<String, Integer> distances = new HashMap<>();\n        Map<String, String> previous = new HashMap<>();\n        PriorityQueue<Node> pq = new PriorityQueue<>();\n        Set<String> visited = new HashSet<>();\n        \n        // Initialize distances\n        for (String vertex : adjacencyList.keySet()) {\n            distances.put(vertex, Integer.MAX_VALUE);\n        }\n        distances.put(start, 0);\n        \n        pq.offer(new Node(start, 0));\n        \n        while (!pq.isEmpty()) {\n            Node current = pq.poll();\n            String currentVertex = current.vertex;\n            \n            if (visited.contains(currentVertex)) {\n                continue;\n            }\n            \n            visited.add(currentVertex);\n            \n            List<Edge> neighbors = adjacencyList.getOrDefault(currentVertex, new ArrayList<>());\n            for (Edge edge : neighbors) {\n                if (visited.contains(edge.destination)) {\n                    continue;\n                }\n                \n                int newDist = distances.get(currentVertex) + edge.weight;\n                \n                if (newDist < distances.get(edge.destination)) {\n                    distances.put(edge.destination, newDist);\n                    previous.put(edge.destination, currentVertex);\n                    pq.offer(new Node(edge.destination, newDist));\n                }\n            }\n        }\n        \n        return distances;\n    }\n    \n    public List<String> getShortestPath(String start, String end) {\n        Map<String, Integer> distances = new HashMap<>();\n        Map<String, String> previous = new HashMap<>();\n        PriorityQueue<Node> pq = new PriorityQueue<>();\n        Set<String> visited = new HashSet<>();\n        \n        // Initialize\n        for (String vertex : adjacencyList.keySet()) {\n            distances.put(vertex, Integer.MAX_VALUE);\n        }\n        distances.put(start, 0);\n        pq.offer(new Node(start, 0));\n        \n        while (!pq.isEmpty()) {\n            Node current = pq.poll();\n            String currentVertex = current.vertex;\n            \n            if (visited.contains(currentVertex)) {\n                continue;\n            }\n            \n            visited.add(currentVertex);\n            \n            if (currentVertex.equals(end)) {\n                break;\n            }\n            \n            List<Edge> neighbors = adjacencyList.getOrDefault(currentVertex, new ArrayList<>());\n            for (Edge edge : neighbors) {\n                if (visited.contains(edge.destination)) {\n                    continue;\n                }\n                \n                int newDist = distances.get(currentVertex) + edge.weight;\n                \n                if (newDist < distances.get(edge.destination)) {\n                    distances.put(edge.destination, newDist);\n                    previous.put(edge.destination, currentVertex);\n                    pq.offer(new Node(edge.destination, newDist));\n                }\n            }\n        }\n        \n        // Reconstruct path\n        List<String> path = new ArrayList<>();\n        String current = end;\n        \n        while (current != null) {\n            path.add(current);\n            current = previous.get(current);\n        }\n        \n        Collections.reverse(path);\n        \n        if (path.get(0).equals(start)) {\n            return path;\n        } else {\n            return new ArrayList<>(); // No path found\n        }\n    }\n    \n    public int getShortestDistance(String start, String end) {\n        Map<String, Integer> distances = dijkstra(start);\n        return distances.getOrDefault(end, Integer.MAX_VALUE);\n    }\n    \n    // Example usage\n    public static void main(String[] args) {\n        WeightedGraph g = new WeightedGraph(false);\n        \n        // Add edges\n        g.addEdge(\"A\", \"B\", 4);\n        g.addEdge(\"A\", \"C\", 2);\n        g.addEdge(\"B\", \"C\", 1);\n        g.addEdge(\"B\", \"D\", 5);\n        g.addEdge(\"C\", \"D\", 8);\n        g.addEdge(\"C\", \"E\", 10);\n        g.addEdge(\"D\", \"E\", 2);\n        \n        // Find shortest distances from A\n        Map<String, Integer> distances = g.dijkstra(\"A\");\n        System.out.println(\"Shortest distances from A: \" + distances);\n        \n        // Find shortest path from A to E\n        List<String> path = g.getShortestPath(\"A\", \"E\");\n        int distance = g.getShortestDistance(\"A\", \"E\");\n        System.out.println(\"Shortest path from A to E: \" + path + \" (distance: \" + distance + \")\");\n    }\n}",
        "csharp": "// C# Dijkstra's Algorithm Implementation\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic class WeightedGraph\n{\n    private Dictionary<string, List<Edge>> adjacencyList;\n    private bool directed;\n    \n    public WeightedGraph(bool directed = true)\n    {\n        this.adjacencyList = new Dictionary<string, List<Edge>>();\n        this.directed = directed;\n    }\n    \n    public class Edge\n    {\n        public string Destination { get; set; }\n        public int Weight { get; set; }\n        \n        public Edge(string destination, int weight)\n        {\n            Destination = destination;\n            Weight = weight;\n        }\n    }\n    \n    public class Node : IComparable<Node>\n    {\n        public string Vertex { get; set; }\n        public int Distance { get; set; }\n        \n        public Node(string vertex, int distance)\n        {\n            Vertex = vertex;\n            Distance = distance;\n        }\n        \n        public int CompareTo(Node other)\n        {\n            return Distance.CompareTo(other.Distance);\n        }\n    }\n    \n    public void AddEdge(string u, string v, int weight)\n    {\n        if (!adjacencyList.ContainsKey(u))\n            adjacencyList[u] = new List<Edge>();\n        adjacencyList[u].Add(new Edge(v, weight));\n        \n        if (!directed)\n        {\n            if (!adjacencyList.ContainsKey(v))\n                adjacencyList[v] = new List<Edge>();\n            adjacencyList[v].Add(new Edge(u, weight));\n        }\n    }\n    \n    public Dictionary<string, int> Dijkstra(string start)\n    {\n        var distances = new Dictionary<string, int>();\n        var previous = new Dictionary<string, string>();\n        var pq = new SortedSet<Node>(Comparer<Node>.Create((x, y) => \n        {\n            int result = x.Distance.CompareTo(y.Distance);\n            return result == 0 ? x.Vertex.CompareTo(y.Vertex) : result;\n        }));\n        var visited = new HashSet<string>();\n        \n        // Initialize distances\n        foreach (string vertex in adjacencyList.Keys)\n        {\n            distances[vertex] = int.MaxValue;\n        }\n        distances[start] = 0;\n        \n        pq.Add(new Node(start, 0));\n        \n        while (pq.Count > 0)\n        {\n            Node current = pq.Min;\n            pq.Remove(current);\n            \n            string currentVertex = current.Vertex;\n            \n            if (visited.Contains(currentVertex))\n                continue;\n            \n            visited.Add(currentVertex);\n            \n            if (adjacencyList.ContainsKey(currentVertex))\n            {\n                foreach (Edge edge in adjacencyList[currentVertex])\n                {\n                    if (visited.Contains(edge.Destination))\n                        continue;\n                    \n                    int newDist = distances[currentVertex] + edge.Weight;\n                    \n                    if (newDist < distances.GetValueOrDefault(edge.Destination, int.MaxValue))\n                    {\n                        distances[edge.Destination] = newDist;\n                        previous[edge.Destination] = currentVertex;\n                        pq.Add(new Node(edge.Destination, newDist));\n                    }\n                }\n            }\n        }\n        \n        return distances;\n    }\n    \n    public (List<string> path, int distance) GetShortestPath(string start, string end)\n    {\n        var distances = new Dictionary<string, int>();\n        var previous = new Dictionary<string, string>();\n        var pq = new SortedSet<Node>(Comparer<Node>.Create((x, y) => \n        {\n            int result = x.Distance.CompareTo(y.Distance);\n            return result == 0 ? x.Vertex.CompareTo(y.Vertex) : result;\n        }));\n        var visited = new HashSet<string>();\n        \n        // Initialize\n        foreach (string vertex in adjacencyList.Keys)\n        {\n            distances[vertex] = int.MaxValue;\n        }\n        distances[start] = 0;\n        pq.Add(new Node(start, 0));\n        \n        while (pq.Count > 0)\n        {\n            Node current = pq.Min;\n            pq.Remove(current);\n            \n            string currentVertex = current.Vertex;\n            \n            if (visited.Contains(currentVertex))\n                continue;\n            \n            visited.Add(currentVertex);\n            \n            if (currentVertex == end)\n                break;\n            \n            if (adjacencyList.ContainsKey(currentVertex))\n            {\n                foreach (Edge edge in adjacencyList[currentVertex])\n                {\n                    if (visited.Contains(edge.Destination))\n                        continue;\n                    \n                    int newDist = distances[currentVertex] + edge.Weight;\n                    \n                    if (newDist < distances.GetValueOrDefault(edge.Destination, int.MaxValue))\n                    {\n                        distances[edge.Destination] = newDist;\n                        previous[edge.Destination] = currentVertex;\n                        pq.Add(new Node(edge.Destination, newDist));\n                    }\n                }\n            }\n        }\n        \n        // Reconstruct path\n        var path = new List<string>();\n        string current = end;\n        \n        while (current != null)\n        {\n            path.Add(current);\n            previous.TryGetValue(current, out current);\n        }\n        \n        path.Reverse();\n        \n        if (path.Count > 0 && path[0] == start)\n        {\n            return (path, distances.GetValueOrDefault(end, int.MaxValue));\n        }\n        else\n        {\n            return (new List<string>(), int.MaxValue);\n        }\n    }\n    \n    public int GetShortestDistance(string start, string end)\n    {\n        var distances = Dijkstra(start);\n        return distances.GetValueOrDefault(end, int.MaxValue);\n    }\n    \n    // Example usage\n    static void Main(string[] args)\n    {\n        WeightedGraph g = new WeightedGraph(false);\n        \n        // Add edges\n        g.AddEdge(\"A\", \"B\", 4);\n        g.AddEdge(\"A\", \"C\", 2);\n        g.AddEdge(\"B\", \"C\", 1);\n        g.AddEdge(\"B\", \"D\", 5);\n        g.AddEdge(\"C\", \"D\", 8);\n        g.AddEdge(\"C\", \"E\", 10);\n        g.AddEdge(\"D\", \"E\", 2);\n        \n        // Find shortest distances from A\n        var distances = g.Dijkstra(\"A\");\n        Console.WriteLine($\"Shortest distances from A: {string.Join(\", \", distances.Select(kvp => $\"{kvp.Key}: {kvp.Value}\"))}\");\n        \n        // Find shortest path from A to E\n        var (path, distance) = g.GetShortestPath(\"A\", \"E\");\n        Console.WriteLine($\"Shortest path from A to E: [{string.Join(\", \", path)}] (distance: {distance})\");\n    }\n}"
      }
    },
     {
      "id": 12,
      "name": "Kadane's Algorithm",
      "category": "Dynamic Programming",
      "description": "An algorithm to find the maximum sum of a contiguous subarray within a one-dimensional array of numbers",
      "time_complexity": {
        "best": "O(n)",
        "average": "O(n)",
        "worst": "O(n)"
      },
      "space_complexity": "O(1)",
      "prerequisites": ["Array understanding", "Dynamic programming basics"],
      "use_cases": ["Maximum subarray problem", "Stock profit maximization", "Signal processing", "Data analysis"],
      "implementations": {
        "python": "def kadanes_algorithm(arr):\n    \"\"\"\n    Kadane's Algorithm implementation in Python\n    \"\"\"\n    if not arr:\n        return 0\n    \n    max_ending_here = max_so_far = arr[0]\n    start = end = 0\n    temp_start = 0\n    \n    for i in range(1, len(arr)):\n        # If current element is greater than sum + current element\n        if arr[i] > max_ending_here + arr[i]:\n            max_ending_here = arr[i]\n            temp_start = i\n        else:\n            max_ending_here = max_ending_here + arr[i]\n        \n        # Update maximum sum and indices\n        if max_ending_here > max_so_far:\n            max_so_far = max_ending_here\n            start = temp_start\n            end = i\n    \n    return max_so_far, start, end\n\ndef kadanes_simple(arr):\n    \"\"\"\n    Simplified version returning only maximum sum\n    \"\"\"\n    if not arr:\n        return 0\n    \n    max_ending_here = max_so_far = arr[0]\n    \n    for i in range(1, len(arr)):\n        max_ending_here = max(arr[i], max_ending_here + arr[i])\n        max_so_far = max(max_so_far, max_ending_here)\n    \n    return max_so_far\n\ndef kadanes_with_all_negative(arr):\n    \"\"\"\n    Handle case where all elements are negative\n    \"\"\"\n    if not arr:\n        return 0\n    \n    max_ending_here = 0\n    max_so_far = float('-inf')\n    \n    for num in arr:\n        max_ending_here = max(num, max_ending_here + num)\n        max_so_far = max(max_so_far, max_ending_here)\n    \n    return max_so_far\n\n# Example usage\nif __name__ == \"__main__\":\n    # Test cases\n    test_arrays = [\n        [-2, -3, 4, -1, -2, 1, 5, -3],\n        [1, 2, 3, 4, 5],\n        [-1, -2, -3, -4],\n        [5, -3, 5],\n        [1]\n    ]\n    \n    for arr in test_arrays:\n        max_sum, start, end = kadanes_algorithm(arr)\n        simple_sum = kadanes_simple(arr)\n        print(f\"Array: {arr}\")\n        print(f\"Maximum sum: {max_sum}\")\n        print(f\"Subarray: {arr[start:end+1]}\")\n        print(f\"Simple version: {simple_sum}\")\n        print(\"-\" * 40)",
        "java": "// Java Kadane's Algorithm Implementation\npublic class KadanesAlgorithm {\n    \n    public static class Result {\n        int maxSum;\n        int start;\n        int end;\n        \n        public Result(int maxSum, int start, int end) {\n            this.maxSum = maxSum;\n            this.start = start;\n            this.end = end;\n        }\n        \n        @Override\n        public String toString() {\n            return String.format(\"MaxSum: %d, Start: %d, End: %d\", maxSum, start, end);\n        }\n    }\n    \n    public static Result kadanesAlgorithm(int[] arr) {\n        if (arr == null || arr.length == 0) {\n            return new Result(0, -1, -1);\n        }\n        \n        int maxEndingHere = arr[0];\n        int maxSoFar = arr[0];\n        int start = 0, end = 0, tempStart = 0;\n        \n        for (int i = 1; i < arr.length; i++) {\n            // If current element is greater than sum + current element\n            if (arr[i] > maxEndingHere + arr[i]) {\n                maxEndingHere = arr[i];\n                tempStart = i;\n            } else {\n                maxEndingHere = maxEndingHere + arr[i];\n            }\n            \n            // Update maximum sum and indices\n            if (maxEndingHere > maxSoFar) {\n                maxSoFar = maxEndingHere;\n                start = tempStart;\n                end = i;\n            }\n        }\n        \n        return new Result(maxSoFar, start, end);\n    }\n    \n    public static int kadanesSimple(int[] arr) {\n        if (arr == null || arr.length == 0) {\n            return 0;\n        }\n        \n        int maxEndingHere = arr[0];\n        int maxSoFar = arr[0];\n        \n        for (int i = 1; i < arr.length; i++) {\n            maxEndingHere = Math.max(arr[i], maxEndingHere + arr[i]);\n            maxSoFar = Math.max(maxSoFar, maxEndingHere);\n        }\n        \n        return maxSoFar;\n    }\n    \n    public static int kadanesWithAllNegative(int[] arr) {\n        if (arr == null || arr.length == 0) {\n            return 0;\n        }\n        \n        int maxEndingHere = 0;\n        int maxSoFar = Integer.MIN_VALUE;\n        \n        for (int num : arr) {\n            maxEndingHere = Math.max(num, maxEndingHere + num);\n            maxSoFar = Math.max(maxSoFar, maxEndingHere);\n        }\n        \n        return maxSoFar;\n    }\n    \n    // 2D version for maximum sum rectangle\n    public static int maxSumRectangle(int[][] matrix) {\n        if (matrix == null || matrix.length == 0) {\n            return 0;\n        }\n        \n        int rows = matrix.length;\n        int cols = matrix[0].length;\n        int maxSum = Integer.MIN_VALUE;\n        \n        for (int top = 0; top < rows; top++) {\n            int[] temp = new int[cols];\n            \n            for (int bottom = top; bottom < rows; bottom++) {\n                // Add current row to temp array\n                for (int i = 0; i < cols; i++) {\n                    temp[i] += matrix[bottom][i];\n                }\n                \n                // Apply Kadane's algorithm on temp array\n                int currentMax = kadanesSimple(temp);\n                maxSum = Math.max(maxSum, currentMax);\n            }\n        }\n        \n        return maxSum;\n    }\n    \n    // Example usage\n    public static void main(String[] args) {\n        int[][] testArrays = {\n            {-2, -3, 4, -1, -2, 1, 5, -3},\n            {1, 2, 3, 4, 5},\n            {-1, -2, -3, -4},\n            {5, -3, 5},\n            {1}\n        };\n        \n        for (int[] arr : testArrays) {\n            Result result = kadanesAlgorithm(arr);\n            int simpleSum = kadanesSimple(arr);\n            \n            System.out.println(\"Array: \" + java.util.Arrays.toString(arr));\n            System.out.println(\"Result: \" + result);\n            System.out.println(\"Simple version: \" + simpleSum);\n            System.out.println(\"-\".repeat(40));\n        }\n        \n        // Test 2D version\n        int[][] matrix = {\n            {1, 2, -1, -4, -20},\n            {-8, -3, 4, 2, 1},\n            {3, 8, 10, 1, 3},\n            {-4, -1, 1, 7, -6}\n        };\n        \n        System.out.println(\"Maximum sum rectangle: \" + maxSumRectangle(matrix));\n    }\n}",
        "csharp": "// C# Kadane's Algorithm Implementation\nusing System;\nusing System.Linq;\n\npublic class KadanesAlgorithm\n{\n    public class Result\n    {\n        public int MaxSum { get; set; }\n        public int Start { get; set; }\n        public int End { get; set; }\n        \n        public Result(int maxSum, int start, int end)\n        {\n            MaxSum = maxSum;\n            Start = start;\n            End = end;\n        }\n        \n        public override string ToString()\n        {\n            return $\"MaxSum: {MaxSum}, Start: {Start}, End: {End}\";\n        }\n    }\n    \n    public static Result KadanesAlgorithm(int[] arr)\n    {\n        if (arr == null || arr.Length == 0)\n        {\n            return new Result(0, -1, -1);\n        }\n        \n        int maxEndingHere = arr[0];\n        int maxSoFar = arr[0];\n        int start = 0, end = 0, tempStart = 0;\n        \n        for (int i = 1; i < arr.Length; i++)\n        {\n            // If current element is greater than sum + current element\n            if (arr[i] > maxEndingHere + arr[i])\n            {\n                maxEndingHere = arr[i];\n                tempStart = i;\n            }\n            else\n            {\n                maxEndingHere = maxEndingHere + arr[i];\n            }\n            \n            // Update maximum sum and indices\n            if (maxEndingHere > maxSoFar)\n            {\n                maxSoFar = maxEndingHere;\n                start = tempStart;\n                end = i;\n            }\n        }\n        \n        return new Result(maxSoFar, start, end);\n    }\n    \n    public static int KadanesSimple(int[] arr)\n    {\n        if (arr == null || arr.Length == 0)\n        {\n            return 0;\n        }\n        \n        int maxEndingHere = arr[0];\n        int maxSoFar = arr[0];\n        \n        for (int i = 1; i < arr.Length; i++)\n        {\n            maxEndingHere = Math.Max(arr[i], maxEndingHere + arr[i]);\n            maxSoFar = Math.Max(maxSoFar, maxEndingHere);\n        }\n        \n        return maxSoFar;\n    }\n    \n    public static int KadanesWithAllNegative(int[] arr)\n    {\n        if (arr == null || arr.Length == 0)\n        {\n            return 0;\n        }\n        \n        int maxEndingHere = 0;\n        int maxSoFar = int.MinValue;\n        \n        foreach (int num in arr)\n        {\n            maxEndingHere = Math.Max(num, maxEndingHere + num);\n            maxSoFar = Math.Max(maxSoFar, maxEndingHere);\n        }\n        \n        return maxSoFar;\n    }\n    \n    // 2D version for maximum sum rectangle\n    public static int MaxSumRectangle(int[,] matrix)\n    {\n        if (matrix == null || matrix.GetLength(0) == 0)\n        {\n            return 0;\n        }\n        \n        int rows = matrix.GetLength(0);\n        int cols = matrix.GetLength(1);\n        int maxSum = int.MinValue;\n        \n        for (int top = 0; top < rows; top++)\n        {\n            int[] temp = new int[cols];\n            \n            for (int bottom = top; bottom < rows; bottom++)\n            {\n                // Add current row to temp array\n                for (int i = 0; i < cols; i++)\n                {\n                    temp[i] += matrix[bottom, i];\n                }\n                \n                // Apply Kadane's algorithm on temp array\n                int currentMax = KadanesSimple(temp);\n                maxSum = Math.Max(maxSum, currentMax);\n            }\n        }\n        \n        return maxSum;\n    }\n    \n    // Circular array version\n    public static int MaxSubarrayCircular(int[] arr)\n    {\n        if (arr == null || arr.Length == 0)\n        {\n            return 0;\n        }\n        \n        // Case 1: Maximum subarray is non-circular\n        int maxKadane = KadanesSimple(arr);\n        \n        // Case 2: Maximum subarray is circular\n        int totalSum = arr.Sum();\n        \n        // Invert all elements and find minimum subarray\n        int[] invertedArr = arr.Select(x => -x).ToArray();\n        int maxInverted = KadanesSimple(invertedArr);\n        int minSubarray = -maxInverted;\n        \n        int maxCircular = totalSum - minSubarray;\n        \n        // Handle case where all elements are negative\n        if (maxCircular == 0)\n        {\n            return maxKadane;\n        }\n        \n        return Math.Max(maxKadane, maxCircular);\n    }\n    \n    // Example usage\n    static void Main(string[] args)\n    {\n        int[][] testArrays = {\n            new int[] {-2, -3, 4, -1, -2, 1, 5, -3},\n            new int[] {1, 2, 3, 4, 5},\n            new int[] {-1, -2, -3, -4},\n            new int[] {5, -3, 5},\n            new int[] {1}\n        };\n        \n        foreach (int[] arr in testArrays)\n        {\n            Result result = KadanesAlgorithm(arr);\n            int simpleSum = KadanesSimple(arr);\n            \n            Console.WriteLine($\"Array: [{string.Join(\", \", arr)}]\");\n            Console.WriteLine($\"Result: {result}\");\n            Console.WriteLine($\"Simple version: {simpleSum}\");\n            Console.WriteLine(new string('-', 40));\n        }\n        \n        // Test 2D version\n        int[,] matrix = {\n            {1, 2, -1, -4, -20},\n            {-8, -3, 4, 2, 1},\n            {3, 8, 10, 1, 3},\n            {-4, -1, 1, 7, -6}\n        };\n        \n        Console.WriteLine($\"Maximum sum rectangle: {MaxSumRectangle(matrix)}\");\n        \n        // Test circular version\n        int[] circularArray = {1, -2, 3, -2};\n        Console.WriteLine($\"Maximum circular subarray: {MaxSubarrayCircular(circularArray)}\");\n    }\n}"
      }
    },
    {
      "id": 13,
      "name": "Two Pointers Technique",
      "category": "Two Pointers",
      "description": "A technique that uses two pointers to iterate through data structures, often used to solve array and string problems efficiently",
      "time_complexity": {
        "best": "O(n)",
        "average": "O(n)",
        "worst": "O(n)"
      },
      "space_complexity": "O(1)",
      "prerequisites": ["Array/string understanding", "Sorting algorithms"],
      "use_cases": ["Two sum problems", "Palindrome checking", "Array partitioning", "Sliding window problems"],
      "implementations": {
        "python": "def two_sum_sorted(arr, target):\n    \"\"\"\n    Find two numbers in sorted array that sum to target\n    \"\"\"\n    left, right = 0, len(arr) - 1\n    \n    while left < right:\n        current_sum = arr[left] + arr[right]\n        \n        if current_sum == target:\n            return [left, right]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return [-1, -1]  # Not found\n\ndef is_palindrome(s):\n    \"\"\"\n    Check if string is palindrome using two pointers\n    \"\"\"\n    # Clean string - keep only alphanumeric\n    cleaned = ''.join(char.lower() for char in s if char.isalnum())\n    \n    left, right = 0, len(cleaned) - 1\n    \n    while left < right:\n        if cleaned[left] != cleaned[right]:\n            return False\n        left += 1\n        right -= 1\n    \n    return True\n\ndef remove_duplicates(arr):\n    \"\"\"\n    Remove duplicates from sorted array in-place\n    \"\"\"\n    if not arr:\n        return 0\n    \n    write_index = 1\n    \n    for read_index in range(1, len(arr)):\n        if arr[read_index] != arr[read_index - 1]:\n            arr[write_index] = arr[read_index]\n            write_index += 1\n    \n    return write_index\n\ndef three_sum(arr, target=0):\n    \"\"\"\n    Find all unique triplets that sum to target\n    \"\"\"\n    arr.sort()\n    result = []\n    \n    for i in range(len(arr) - 2):\n        # Skip duplicates for first element\n        if i > 0 and arr[i] == arr[i - 1]:\n            continue\n        \n        left, right = i + 1, len(arr) - 1\n        \n        while left < right:\n            current_sum = arr[i] + arr[left] + arr[right]\n            \n            if current_sum == target:\n                result.append([arr[i], arr[left], arr[right]])\n                \n                # Skip duplicates\n                while left < right and arr[left] == arr[left + 1]:\n                    left += 1\n                while left < right and arr[right] == arr[right - 1]:\n                    right -= 1\n                \n                left += 1\n                right -= 1\n            elif current_sum < target:\n                left += 1\n            else:\n                right -= 1\n    \n    return result\n\ndef container_with_most_water(heights):\n    \"\"\"\n    Find container that can hold most water\n    \"\"\"\n    left, right = 0, len(heights) - 1\n    max_area = 0\n    \n    while left < right:\n        # Calculate current area\n        width = right - left\n        height = min(heights[left], heights[right])\n        area = width * height\n        max_area = max(max_area, area)\n        \n        # Move pointer with smaller height\n        if heights[left] < heights[right]:\n            left += 1\n        else:\n            right -= 1\n    \n    return max_area\n\ndef partition_array(arr, pivot):\n    \"\"\"\n    Partition array around pivot value\n    \"\"\"\n    left, right = 0, len(arr) - 1\n    \n    while left <= right:\n        # Find element >= pivot from left\n        while left <= right and arr[left] < pivot:\n            left += 1\n        \n        # Find element < pivot from right\n        while left <= right and arr[right] >= pivot:\n            right -= 1\n        \n        # Swap if both pointers are valid\n        if left < right:\n            arr[left], arr[right] = arr[right], arr[left]\n            left += 1\n            right -= 1\n    \n    return left  # Return partition index\n\ndef reverse_words_in_string(s):\n    \"\"\"\n    Reverse words in string using two pointers\n    \"\"\"\n    chars = list(s)\n    n = len(chars)\n    \n    # Reverse entire string\n    left, right = 0, n - 1\n    while left < right:\n        chars[left], chars[right] = chars[right], chars[left]\n        left += 1\n        right -= 1\n    \n    # Reverse each word\n    start = 0\n    for end in range(n + 1):\n        if end == n or chars[end] == ' ':\n            # Reverse word from start to end-1\n            left, right = start, end - 1\n            while left < right:\n                chars[left], chars[right] = chars[right], chars[left]\n                left += 1\n                right -= 1\n            start = end + 1\n    \n    return ''.join(chars)\n\n# Example usage and testing\nif __name__ == \"__main__\":\n    # Test two sum\n    print(\"Two Sum:\", two_sum_sorted([1, 2, 3, 4, 6], 6))  # [1, 3]\n    \n    # Test palindrome\n    print(\"Palindrome:\", is_palindrome(\"A man, a plan, a canal: Panama\"))  # True\n    \n    # Test remove duplicates\n    arr = [1, 1, 2, 2, 3, 4, 4, 5]\n    length = remove_duplicates(arr)\n    print(\"Remove duplicates:\", arr[:length])  # [1, 2, 3, 4, 5]\n    \n    # Test three sum\n    print(\"Three Sum:\", three_sum([-1, 0, 1, 2, -1, -4]))  # [[-1, -1, 2], [-1, 0, 1]]\n    \n    # Test container with most water\n    print(\"Max Water:\", container_with_most_water([1, 8, 6, 2, 5, 4, 8, 3, 7]))  # 49",
        "java": "// Java Two Pointers Technique Implementation\nimport java.util.*;\n\npublic class TwoPointers {\n    \n    // Find two numbers in sorted array that sum to target\n    public static int[] twoSumSorted(int[] arr, int target) {\n        int left = 0, right = arr.length - 1;\n        \n        while (left < right) {\n            int currentSum = arr[left] + arr[right];\n            \n            if (currentSum == target) {\n                return new int[]{left, right};\n            } else if (currentSum < target) {\n                left++;\n            } else {\n                right--;\n            }\n        }\n        \n        return new int[]{-1, -1}; // Not found\n    }\n    \n    // Check if string is palindrome\n    public static boolean isPalindrome(String s) {\n        // Clean string - keep only alphanumeric\n        StringBuilder cleaned = new StringBuilder();\n        for (char c : s.toCharArray()) {\n            if (Character.isLetterOrDigit(c)) {\n                cleaned.append(Character.toLowerCase(c));\n            }\n        }\n        \n        int left = 0, right = cleaned.length() - 1;\n        \n        while (left < right) {\n            if (cleaned.charAt(left) != cleaned.charAt(right)) {\n                return false;\n            }\n            left++;\n            right--;\n        }\n        \n        return true;\n    }\n    \n    // Remove duplicates from sorted array in-place\n    public static int removeDuplicates(int[] arr) {\n        if (arr.length == 0) return 0;\n        \n        int writeIndex = 1;\n        \n        for (int readIndex = 1; readIndex < arr.length; readIndex++) {\n            if (arr[readIndex] != arr[readIndex - 1]) {\n                arr[writeIndex] = arr[readIndex];\n                writeIndex++;\n            }\n        }\n        \n        return writeIndex;\n    }\n    \n    // Find all unique triplets that sum to target\n    public static List<List<Integer>> threeSum(int[] arr, int target) {\n        Arrays.sort(arr);\n        List<List<Integer>> result = new ArrayList<>();\n        \n        for (int i = 0; i < arr.length - 2; i++) {\n            // Skip duplicates for first element\n            if (i > 0 && arr[i] == arr[i - 1]) {\n                continue;\n            }\n            \n            int left = i + 1, right = arr.length - 1;\n            \n            while (left < right) {\n                int currentSum = arr[i] + arr[left] + arr[right];\n                \n                if (currentSum == target) {\n                    result.add(Arrays.asList(arr[i], arr[left], arr[right]));\n                    \n                    // Skip duplicates\n                    while (left < right && arr[left] == arr[left + 1]) {\n                        left++;\n                    }\n                    while (left < right && arr[right] == arr[right - 1]) {\n                        right--;\n                    }\n                    \n                    left++;\n                    right--;\n                } else if (currentSum < target) {\n                    left++;\n                } else {\n                    right--;\n                }\n            }\n        }\n        \n        return result;\n    }\n    \n    // Find container that can hold most water\n    public static int containerWithMostWater(int[] heights) {\n        int left = 0, right = heights.length - 1;\n        int maxArea = 0;\n        \n        while (left < right) {\n            // Calculate current area\n            int width = right - left;\n            int height = Math.min(heights[left], heights[right]);\n            int area = width * height;\n            maxArea = Math.max(maxArea, area);\n            \n            // Move pointer with smaller height\n            if (heights[left] < heights[right]) {\n                left++;\n            } else {\n                right--;\n            }\n        }\n        \n        return maxArea;\n    }\n    \n    // Partition array around pivot value\n    public static int partitionArray(int[] arr, int pivot) {\n        int left = 0, right = arr.length - 1;\n        \n        while (left <= right) {\n            // Find element >= pivot from left\n            while (left <= right && arr[left] < pivot) {\n                left++;\n            }\n            \n            // Find element < pivot from right\n            while (left <= right && arr[right] >= pivot) {\n                right--;\n            }\n            \n            // Swap if both pointers are valid\n            if (left < right) {\n                int temp = arr[left];\n                arr[left] = arr[right];\n                arr[right] = temp;\n                left++;\n                right--;\n            }\n        }\n        \n        return left; // Return partition index\n    }\n    \n    // Reverse words in string\n    public static String reverseWordsInString(String s) {\n        char[] chars = s.toCharArray();\n        int n = chars.length;\n        \n        // Reverse entire string\n        reverse(chars, 0, n - 1);\n        \n        // Reverse each word\n        int start = 0;\n        for (int end = 0; end <= n; end++) {\n            if (end == n || chars[end] == ' ') {\n                reverse(chars, start, end - 1);\n                start = end + 1;\n            }\n        }\n        \n        return new String(chars);\n    }\n    \n    private static void reverse(char[] chars, int left, int right) {\n        while (left < right) {\n            char temp = chars[left];\n            chars[left] = chars[right];\n            chars[right] = temp;\n            left++;\n            right--;\n        }\n    }\n    \n    // Sliding window maximum\n    public static int[] slidingWindowMaximum(int[] arr, int k) {\n        if (arr.length == 0 || k == 0) return new int[0];\n        \n        int[] result = new int[arr.length - k + 1];\n        Deque<Integer> deque = new ArrayDeque<>();\n        \n        for (int i = 0; i < arr.length; i++) {\n            // Remove elements outside window\n            while (!deque.isEmpty() && deque.peekFirst() < i - k + 1) {\n                deque.pollFirst();\n            }\n            \n            // Remove smaller elements from rear\n            while (!deque.isEmpty() && arr[deque.peekLast()] < arr[i]) {\n                deque.pollLast();\n            }\n            \n            deque.offerLast(i);\n            \n            // Add to result when window is complete\n            if (i >= k - 1) {\n                result[i - k + 1] = arr[deque.peekFirst()];\n            }\n        }\n        \n        return result;\n    }\n    \n    // Example usage\n    public static void main(String[] args) {\n        // Test two sum\n        int[] twoSumResult = twoSumSorted(new int[]{1, 2, 3, 4, 6}, 6);\n        System.out.println(\"Two Sum: \" + Arrays.toString(twoSumResult));\n        \n        // Test palindrome\n        System.out.println(\"Palindrome: \" + isPalindrome(\"A man, a plan, a canal: Panama\"));\n        \n        // Test remove duplicates\n        int[] arr = {1, 1, 2, 2, 3, 4, 4, 5};\n        int length = removeDuplicates(arr);\n        System.out.println(\"Remove duplicates: \" + Arrays.toString(Arrays.copyOf(arr, length)));\n        \n        // Test three sum\n        List<List<Integer>> threeSumResult = threeSum(new int[]{-1, 0, 1, 2, -1, -4}, 0);\n        System.out.println(\"Three Sum: \" + threeSumResult);\n        \n        // Test container with most water\n        int maxWater = containerWithMostWater(new int[]{1, 8, 6, 2, 5, 4, 8, 3, 7});\n        System.out.println(\"Max Water: \" + maxWater);\n    }\n}",
        "csharp": "// C# Two Pointers Technique Implementation\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\npublic class TwoPointers\n{\n    // Find two numbers in sorted array that sum to target\n    public static int[] TwoSumSorted(int[] arr, int target)\n    {\n        int left = 0, right = arr.Length - 1;\n        \n        while (left < right)\n        {\n            int currentSum = arr[left] + arr[right];\n            \n            if (currentSum == target)\n            {\n                return new int[] { left, right };\n            }\n            else if (currentSum < target)\n            {\n                left++;\n            }\n            else\n            {\n                right--;\n            }\n        }\n        \n        return new int[] { -1, -1 }; // Not found\n    }\n    \n    // Check if string is palindrome\n    public static bool IsPalindrome(string s)\n    {\n        // Clean string - keep only alphanumeric\n        var cleaned = new StringBuilder();\n        foreach (char c in s)\n        {\n            if (char.IsLetterOrDigit(c))\n            {\n                cleaned.Append(char.ToLower(c));\n            }\n        }\n        \n        int left = 0, right = cleaned.Length - 1;\n        \n        while (left < right)\n        {\n            if (cleaned[left] != cleaned[right])\n            {\n                return false;\n            }\n            left++;\n            right--;\n        }\n        \n        return true;\n    }\n    \n    // Remove duplicates from sorted array in-place\n    public static int RemoveDuplicates(int[] arr)\n    {\n        if (arr.Length == 0) return 0;\n        \n        int writeIndex = 1;\n        \n        for (int readIndex = 1; readIndex < arr.Length; readIndex++)\n        {\n            if (arr[readIndex] != arr[readIndex - 1])\n            {\n                arr[writeIndex] = arr[readIndex];\n                writeIndex++;\n            }\n        }\n        \n        return writeIndex;\n    }\n    \n    // Find all unique triplets that sum to target\n    public static List<List<int>> ThreeSum(int[] arr, int target = 0)\n    {\n        Array.Sort(arr);\n        var result = new List<List<int>>();\n        \n        for (int i = 0; i < arr.Length - 2; i++)\n        {\n            // Skip duplicates for first element\n            if (i > 0 && arr[i] == arr[i - 1])\n            {\n                continue;\n            }\n            \n            int left = i + 1, right = arr.Length - 1;\n            \n            while (left < right)\n            {\n                int currentSum = arr[i] + arr[left] + arr[right];\n                \n                if (currentSum == target)\n                {\n                    result.Add(new List<int> { arr[i], arr[left], arr[right] });\n                    \n                    // Skip duplicates\n                    while (left < right && arr[left] == arr[left + 1])\n                    {\n                        left++;\n                    }\n                    while (left < right && arr[right] == arr[right - 1])\n                    {\n                        right--;\n                    }\n                    \n                    left++;\n                    right--;\n                }\n                else if (currentSum < target)\n                {\n                    left++;\n                }\n                else\n                {\n                    right--;\n                }\n            }\n        }\n        \n        return result;\n    }\n    \n    // Find container that can hold most water\n    public static int ContainerWithMostWater(int[] heights)\n    {\n        int left = 0, right = heights.Length - 1;\n        int maxArea = 0;\n        \n        while (left < right)\n        {\n            // Calculate current area\n            int width = right - left;\n            int height = Math.Min(heights[left], heights[right]);\n            int area = width * height;\n            maxArea = Math.Max(maxArea, area);\n            \n            // Move pointer with smaller height\n            if (heights[left] < heights[right])\n            {\n                left++;\n            }\n            else\n            {\n                right--;\n            }\n        }\n        \n        return maxArea;\n    }\n    \n    // Partition array around pivot value\n    public static int PartitionArray(int[] arr, int pivot)\n    {\n        int left = 0, right = arr.Length - 1;\n        \n        while (left <= right)\n        {\n            // Find element >= pivot from left\n            while (left <= right && arr[left] < pivot)\n            {\n                left++;\n            }\n            \n            // Find element < pivot from right\n            while (left <= right && arr[right] >= pivot)\n            {\n                right--;\n            }\n            \n            // Swap if both pointers are valid\n            if (left < right)\n            {\n                (arr[left], arr[right]) = (arr[right], arr[left]);\n                left++;\n                right--;\n            }\n        }\n        \n        return left; // Return partition index\n    }\n    \n    // Reverse words in string\n    public static string ReverseWordsInString(string s)\n    {\n        char[] chars = s.ToCharArray();\n        int n = chars.Length;\n        \n        // Reverse entire string\n        Reverse(chars, 0, n - 1);\n        \n        // Reverse each word\n        int start = 0;\n        for (int end = 0; end <= n; end++)\n        {\n            if (end == n || chars[end] == ' ')\n            {\n                Reverse(chars, start, end - 1);\n                start = end + 1;\n            }\n        }\n        \n        return new string(chars);\n    }\n    \n    private static void Reverse(char[] chars, int left, int right)\n    {\n        while (left < right)\n        {\n            (chars[left], chars[right]) = (chars[right], chars[left]);\n            left++;\n            right--;\n        }\n    }\n    \n    // Sliding window maximum using deque\n    public static int[] SlidingWindowMaximum(int[] arr, int k)\n    {\n        if (arr.Length == 0 || k == 0) return new int[0];\n        \n        int[] result = new int[arr.Length - k + 1];\n        var deque = new LinkedList<int>();\n        \n        for (int i = 0; i < arr.Length; i++)\n        {\n            // Remove elements outside window\n            while (deque.Count > 0 && deque.First.Value < i - k + 1)\n            {\n                deque.RemoveFirst();\n            }\n            \n            // Remove smaller elements from rear\n            while (deque.Count > 0 && arr[deque.Last.Value] < arr[i])\n            {\n                deque.RemoveLast();\n            }\n            \n            deque.AddLast(i);\n            \n            // Add to result when window is complete\n            if (i >= k - 1)\n            {\n                result[i - k + 1] = arr[deque.First.Value];\n            }\n        }\n        \n        return result;\n    }\n    \n    // Example usage\n    static void Main(string[] args)\n    {\n        // Test two sum\n        int[] twoSumResult = TwoSumSorted(new int[] { 1, 2, 3, 4, 6 }, 6);\n        Console.WriteLine($\"Two Sum: [{string.Join(\", \", twoSumResult)}]\");\n        \n        // Test palindrome\n        Console.WriteLine($\"Palindrome: {IsPalindrome(\"A man, a plan, a canal: Panama\")}\");\n        \n        // Test remove duplicates\n        int[] arr = { 1, 1, 2, 2, 3, 4, 4, 5 };\n        int length = RemoveDuplicates(arr);\n        Console.WriteLine($\"Remove duplicates: [{string.Join(\", \", arr.Take(length))}]\");\n        \n        // Test three sum\n        var threeSumResult = ThreeSum(new int[] { -1, 0, 1, 2, -1, -4 });\n        Console.WriteLine($\"Three Sum: [{string.Join(\", \", threeSumResult.Select(list => $\"[{string.Join(\", \", list)}]\"))}]\");\n        \n        // Test container with most water\n        int maxWater = ContainerWithMostWater(new int[] { 1, 8, 6, 2, 5, 4, 8, 3, 7 });\n        Console.WriteLine($\"Max Water: {maxWater}\");\n    }\n}\n"
      }
    },
    {
      "id": 14,
      "name": "Heap Sort",
      "category": "Sorting",
      "description": "A comparison-based sorting algorithm that uses a binary heap data structure to sort elements in-place",
      "time_complexity": {
        "best": "O(n log n)",
        "average": "O(n log n)",
        "worst": "O(n log n)"
      },
      "space_complexity": "O(1)",
      "prerequisites": ["Binary heap understanding", "Array manipulation"],
      "use_cases": ["Memory-constrained sorting", "Guaranteed O(n log n) performance", "Priority queue implementation", "External sorting"],
      "implementations": {
        "python": "def heap_sort(arr):\n    \"\"\"\n    Heap sort implementation in Python\n    \"\"\"\n    def heapify(arr, n, i):\n        \"\"\"Maintain heap property for subtree rooted at index i\"\"\"\n        largest = i  # Initialize largest as root\n        left = 2 * i + 1\n        right = 2 * i + 2\n        \n        # Check if left child exists and is greater than root\n        if left < n and arr[left] > arr[largest]:\n            largest = left\n        \n        # Check if right child exists and is greater than largest so far\n        if right < n and arr[right] > arr[largest]:\n            largest = right\n        \n        # If largest is not root, swap and continue heapifying\n        if largest != i:\n            arr[i], arr[largest] = arr[largest], arr[i]\n            heapify(arr, n, largest)\n    \n    def build_max_heap(arr):\n        \"\"\"Build max heap from unsorted array\"\"\"\n        n = len(arr)\n        # Start from last non-leaf node and heapify each node\n        for i in range(n // 2 - 1, -1, -1):\n            heapify(arr, n, i)\n    \n    n = len(arr)\n    \n    # Build max heap\n    build_max_heap(arr)\n    \n    # Extract elements from heap one by one\n    for i in range(n - 1, 0, -1):\n        # Move current root to end\n        arr[0], arr[i] = arr[i], arr[0]\n        \n        # Call heapify on the reduced heap\n        heapify(arr, i, 0)\n    \n    return arr\n\ndef heap_sort_iterative(arr):\n    \"\"\"\n    Iterative version of heap sort\n    \"\"\"\n    def sift_down(arr, start, end):\n        \"\"\"Sift down element at start index\"\"\"\n        root = start\n        \n        while root * 2 + 1 <= end:\n            child = root * 2 + 1\n            swap = root\n            \n            # Check left child\n            if arr[swap] < arr[child]:\n                swap = child\n            \n            # Check right child\n            if child + 1 <= end and arr[swap] < arr[child + 1]:\n                swap = child + 1\n            \n            if swap == root:\n                return\n            else:\n                arr[root], arr[swap] = arr[swap], arr[root]\n                root = swap\n    \n    # Build heap (heapify)\n    start = (len(arr) - 2) // 2\n    while start >= 0:\n        sift_down(arr, start, len(arr) - 1)\n        start -= 1\n    \n    # Extract elements from heap\n    end = len(arr) - 1\n    while end > 0:\n        arr[0], arr[end] = arr[end], arr[0]\n        end -= 1\n        sift_down(arr, 0, end)\n    \n    return arr\n\n# Example usage\nif __name__ == \"__main__\":\n    # Test heap sort\n    test_arrays = [\n        [64, 34, 25, 12, 22, 11, 90],\n        [5, 2, 8, 1, 9],\n        [1],\n        [],\n        [3, 3, 3, 3]\n    ]\n    \n    for arr in test_arrays:\n        original = arr.copy()\n        sorted_arr = heap_sort(arr.copy())\n        print(f\"Original: {original}\")\n        print(f\"Sorted:   {sorted_arr}\")\n        print(\"-\" * 40)",
        "java": "// Java Heap Sort Implementation\npublic class HeapSort {\n    \n    public static void heapSort(int[] arr) {\n        int n = arr.length;\n        \n        // Build max heap\n        buildMaxHeap(arr);\n        \n        // Extract elements from heap one by one\n        for (int i = n - 1; i > 0; i--) {\n            // Move current root to end\n            swap(arr, 0, i);\n            \n            // Call heapify on the reduced heap\n            heapify(arr, i, 0);\n        }\n    }\n    \n    private static void buildMaxHeap(int[] arr) {\n        int n = arr.length;\n        \n        // Start from last non-leaf node and heapify each node\n        for (int i = n / 2 - 1; i >= 0; i--) {\n            heapify(arr, n, i);\n        }\n    }\n    \n    private static void heapify(int[] arr, int n, int i) {\n        int largest = i; // Initialize largest as root\n        int left = 2 * i + 1;\n        int right = 2 * i + 2;\n        \n        // Check if left child exists and is greater than root\n        if (left < n && arr[left] > arr[largest]) {\n            largest = left;\n        }\n        \n        // Check if right child exists and is greater than largest so far\n        if (right < n && arr[right] > arr[largest]) {\n            largest = right;\n        }\n        \n        // If largest is not root, swap and continue heapifying\n        if (largest != i) {\n            swap(arr, i, largest);\n            heapify(arr, n, largest);\n        }\n    }\n    \n    private static void swap(int[] arr, int i, int j) {\n        int temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }\n    \n    // Alternative implementation with iterative heapify\n    public static void heapSortIterative(int[] arr) {\n        int n = arr.length;\n        \n        // Build heap\n        for (int i = n / 2 - 1; i >= 0; i--) {\n            siftDown(arr, i, n - 1);\n        }\n        \n        // Extract elements from heap\n        for (int end = n - 1; end > 0; end--) {\n            swap(arr, 0, end);\n            siftDown(arr, 0, end - 1);\n        }\n    }\n    \n    private static void siftDown(int[] arr, int start, int end) {\n        int root = start;\n        \n        while (root * 2 + 1 <= end) {\n            int child = root * 2 + 1;\n            int swapIdx = root;\n            \n            // Check left child\n            if (arr[swapIdx] < arr[child]) {\n                swapIdx = child;\n            }\n            \n            // Check right child\n            if (child + 1 <= end && arr[swapIdx] < arr[child + 1]) {\n                swapIdx = child + 1;\n            }\n            \n            if (swapIdx == root) {\n                return;\n            } else {\n                swap(arr, root, swapIdx);\n                root = swapIdx;\n            }\n        }\n    }\n    \n    // Utility method to print array\n    public static void printArray(int[] arr) {\n        for (int value : arr) {\n            System.out.print(value + \" \");\n        }\n        System.out.println();\n    }\n    \n    // Example usage\n    public static void main(String[] args) {\n        int[][] testArrays = {\n            {64, 34, 25, 12, 22, 11, 90},\n            {5, 2, 8, 1, 9},\n            {1},\n            {3, 3, 3, 3}\n        };\n        \n        for (int[] arr : testArrays) {\n            int[] original = arr.clone();\n            \n            System.out.print(\"Original: \");\n            printArray(original);\n            \n            heapSort(arr);\n            System.out.print(\"Sorted:   \");\n            printArray(arr);\n            System.out.println(\"-\".repeat(40));\n        }\n    }\n}",
        "csharp": "// C# Heap Sort Implementation\nusing System;\n\npublic class HeapSort\n{\n    public static void Sort(int[] arr)\n    {\n        int n = arr.Length;\n        \n        // Build max heap\n        BuildMaxHeap(arr);\n        \n        // Extract elements from heap one by one\n        for (int i = n - 1; i > 0; i--)\n        {\n            // Move current root to end\n            Swap(arr, 0, i);\n            \n            // Call heapify on the reduced heap\n            Heapify(arr, i, 0);\n        }\n    }\n    \n    private static void BuildMaxHeap(int[] arr)\n    {\n        int n = arr.Length;\n        \n        // Start from last non-leaf node and heapify each node\n        for (int i = n / 2 - 1; i >= 0; i--)\n        {\n            Heapify(arr, n, i);\n        }\n    }\n    \n    private static void Heapify(int[] arr, int n, int i)\n    {\n        int largest = i; // Initialize largest as root\n        int left = 2 * i + 1;\n        int right = 2 * i + 2;\n        \n        // Check if left child exists and is greater than root\n        if (left < n && arr[left] > arr[largest])\n        {\n            largest = left;\n        }\n        \n        // Check if right child exists and is greater than largest so far\n        if (right < n && arr[right] > arr[largest])\n        {\n            largest = right;\n        }\n        \n        // If largest is not root, swap and continue heapifying\n        if (largest != i)\n        {\n            Swap(arr, i, largest);\n            Heapify(arr, n, largest);\n        }\n    }\n    \n    private static void Swap(int[] arr, int i, int j)\n    {\n        (arr[i], arr[j]) = (arr[j], arr[i]);\n    }\n    \n    // Alternative implementation with iterative heapify\n    public static void SortIterative(int[] arr)\n    {\n        int n = arr.Length;\n        \n        // Build heap\n        for (int i = n / 2 - 1; i >= 0; i--)\n        {\n            SiftDown(arr, i, n - 1);\n        }\n        \n        // Extract elements from heap\n        for (int end = n - 1; end > 0; end--)\n        {\n            Swap(arr, 0, end);\n            SiftDown(arr, 0, end - 1);\n        }\n    }\n    \n    private static void SiftDown(int[] arr, int start, int end)\n    {\n        int root = start;\n        \n        while (root * 2 + 1 <= end)\n        {\n            int child = root * 2 + 1;\n            int swapIdx = root;\n            \n            // Check left child\n            if (arr[swapIdx] < arr[child])\n            {\n                swapIdx = child;\n            }\n            \n            // Check right child\n            if (child + 1 <= end && arr[swapIdx] < arr[child + 1])\n            {\n                swapIdx = child + 1;\n            }\n            \n            if (swapIdx == root)\n            {\n                return;\n            }\n            else\n            {\n                Swap(arr, root, swapIdx);\n                root = swapIdx;\n            }\n        }\n    }\n    \n    // Generic version for any comparable type\n    public static void Sort<T>(T[] arr) where T : IComparable<T>\n    {\n        int n = arr.Length;\n        \n        // Build max heap\n        for (int i = n / 2 - 1; i >= 0; i--)\n        {\n            HeapifyGeneric(arr, n, i);\n        }\n        \n        // Extract elements from heap one by one\n        for (int i = n - 1; i > 0; i--)\n        {\n            (arr[0], arr[i]) = (arr[i], arr[0]);\n            HeapifyGeneric(arr, i, 0);\n        }\n    }\n    \n    private static void HeapifyGeneric<T>(T[] arr, int n, int i) where T : IComparable<T>\n    {\n        int largest = i;\n        int left = 2 * i + 1;\n        int right = 2 * i + 2;\n        \n        if (left < n && arr[left].CompareTo(arr[largest]) > 0)\n        {\n            largest = left;\n        }\n        \n        if (right < n && arr[right].CompareTo(arr[largest]) > 0)\n        {\n            largest = right;\n        }\n        \n        if (largest != i)\n        {\n            (arr[i], arr[largest]) = (arr[largest], arr[i]);\n            HeapifyGeneric(arr, n, largest);\n        }\n    }\n    \n    // Example usage\n    static void Main(string[] args)\n    {\n        int[][] testArrays = {\n            new int[] {64, 34, 25, 12, 22, 11, 90},\n            new int[] {5, 2, 8, 1, 9},\n            new int[] {1},\n            new int[] {3, 3, 3, 3}\n        };\n        \n        foreach (int[] arr in testArrays)\n        {\n            int[] original = (int[])arr.Clone();\n            \n            Console.WriteLine($\"Original: [{string.Join(\", \", original)}]\");\n            \n            Sort(arr);\n            Console.WriteLine($\"Sorted:   [{string.Join(\", \", arr)}]\");\n            Console.WriteLine(new string('-', 40));\n        }\n    }\n}"
      }
    },
    {
      "id": 15,
      "name": "A* Search Algorithm",
      "category": "Graph",
      "description": "A graph traversal and path search algorithm that uses heuristics to find the optimal path from start to goal efficiently",
      "time_complexity": {
        "best": "O(b^d)",
        "average": "O(b^d)",
        "worst": "O(b^d)"
      },
      "space_complexity": "O(b^d)",
      "prerequisites": ["Graph representation", "Priority queue", "Heuristic functions"],
      "use_cases": ["Pathfinding in games", "GPS navigation", "Robotics", "AI planning"],
      "implementations": {
        "python": "import heapq\nimport math\nfrom typing import List, Tuple, Dict, Set, Optional\n\nclass Node:\n    \"\"\"Node class for A* algorithm\"\"\"\n    def __init__(self, position: Tuple[int, int], g_cost: float = 0, h_cost: float = 0, parent=None):\n        self.position = position\n        self.g_cost = g_cost  # Cost from start to current node\n        self.h_cost = h_cost  # Heuristic cost from current node to goal\n        self.f_cost = g_cost + h_cost  # Total cost\n        self.parent = parent\n    \n    def __lt__(self, other):\n        return self.f_cost < other.f_cost\n    \n    def __eq__(self, other):\n        return self.position == other.position\n    \n    def __hash__(self):\n        return hash(self.position)\n\ndef manhattan_distance(pos1: Tuple[int, int], pos2: Tuple[int, int]) -> float:\n    \"\"\"Calculate Manhattan distance heuristic\"\"\"\n    return abs(pos1[0] - pos2[0]) + abs(pos1[1] - pos2[1])\n\ndef euclidean_distance(pos1: Tuple[int, int], pos2: Tuple[int, int]) -> float:\n    \"\"\"Calculate Euclidean distance heuristic\"\"\"\n    return math.sqrt((pos1[0] - pos2[0])**2 + (pos1[1] - pos2[1])**2)\n\ndef diagonal_distance(pos1: Tuple[int, int], pos2: Tuple[int, int]) -> float:\n    \"\"\"Calculate diagonal distance (Chebyshev) heuristic\"\"\"\n    dx = abs(pos1[0] - pos2[0])\n    dy = abs(pos1[1] - pos2[1])\n    return max(dx, dy)\n\ndef astar_search(grid: List[List[int]], start: Tuple[int, int], goal: Tuple[int, int], \n                heuristic=manhattan_distance, allow_diagonal=False) -> Optional[List[Tuple[int, int]]]:\n    \"\"\"\n    A* pathfinding algorithm\n    \n    Args:\n        grid: 2D grid where 0 = walkable, 1 = obstacle\n        start: Starting position (row, col)\n        goal: Goal position (row, col)\n        heuristic: Heuristic function to use\n        allow_diagonal: Whether diagonal movement is allowed\n    \n    Returns:\n        List of positions representing the path, or None if no path exists\n    \"\"\"\n    if not grid or not grid[0]:\n        return None\n    \n    rows, cols = len(grid), len(grid[0])\n    \n    # Check if start and goal are valid\n    if (start[0] < 0 or start[0] >= rows or start[1] < 0 or start[1] >= cols or\n        goal[0] < 0 or goal[0] >= rows or goal[1] < 0 or goal[1] >= cols or\n        grid[start[0]][start[1]] == 1 or grid[goal[0]][goal[1]] == 1):\n        return None\n    \n    # Define possible movements\n    if allow_diagonal:\n        movements = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]\n        move_costs = [1.414, 1, 1.414, 1, 1, 1.414, 1, 1.414]  # Diagonal moves cost sqrt(2)\n    else:\n        movements = [(-1, 0), (1, 0), (0, -1), (0, 1)]  # Up, Down, Left, Right\n        move_costs = [1, 1, 1, 1]\n    \n    # Initialize open and closed sets\n    open_set = []\n    closed_set: Set[Tuple[int, int]] = set()\n    \n    # Create start node\n    start_node = Node(start, 0, heuristic(start, goal))\n    heapq.heappush(open_set, start_node)\n    \n    # Keep track of best g_cost for each position\n    g_costs: Dict[Tuple[int, int], float] = {start: 0}\n    \n    while open_set:\n        current_node = heapq.heappop(open_set)\n        \n        # Check if we reached the goal\n        if current_node.position == goal:\n            return reconstruct_path(current_node)\n        \n        closed_set.add(current_node.position)\n        \n        # Explore neighbors\n        for i, (dx, dy) in enumerate(movements):\n            neighbor_pos = (current_node.position[0] + dx, current_node.position[1] + dy)\n            \n            # Check bounds and obstacles\n            if (neighbor_pos[0] < 0 or neighbor_pos[0] >= rows or\n                neighbor_pos[1] < 0 or neighbor_pos[1] >= cols or\n                grid[neighbor_pos[0]][neighbor_pos[1]] == 1 or\n                neighbor_pos in closed_set):\n                continue\n            \n            # Calculate tentative g_cost\n            tentative_g = current_node.g_cost + move_costs[i]\n            \n            # Check if this path is better\n            if neighbor_pos not in g_costs or tentative_g < g_costs[neighbor_pos]:\n                g_costs[neighbor_pos] = tentative_g\n                h_cost = heuristic(neighbor_pos, goal)\n                neighbor_node = Node(neighbor_pos, tentative_g, h_cost, current_node)\n                heapq.heappush(open_set, neighbor_node)\n    \n    return None  # No path found\n\ndef reconstruct_path(node: Node) -> List[Tuple[int, int]]:\n    \"\"\"Reconstruct path from goal node to start\"\"\"\n    path = []\n    current = node\n    while current:\n        path.append(current.position)\n        current = current.parent\n    return path[::-1]  # Reverse to get path from start to goal\n\ndef astar_with_weights(graph: Dict[str, Dict[str, float]], start: str, goal: str,\n                      heuristic_func) -> Optional[Tuple[List[str], float]]:\n    \"\"\"\n    A* algorithm for weighted graphs\n    \n    Args:\n        graph: Adjacency list with weights {node: {neighbor: weight}}\n        start: Start node\n        goal: Goal node\n        heuristic_func: Function that takes a node and returns heuristic cost to goal\n    \n    Returns:\n        Tuple of (path, total_cost) or None if no path exists\n    \"\"\"\n    open_set = [(0, start, [start], 0)]  # (f_cost, node, path, g_cost)\n    closed_set = set()\n    best_g_costs = {start: 0}\n    \n    while open_set:\n        f_cost, current, path, g_cost = heapq.heappop(open_set)\n        \n        if current == goal:\n            return path, g_cost\n        \n        if current in closed_set:\n            continue\n        \n        closed_set.add(current)\n        \n        for neighbor, weight in graph.get(current, {}).items():\n            if neighbor in closed_set:\n                continue\n            \n            tentative_g = g_cost + weight\n            \n            if neighbor not in best_g_costs or tentative_g < best_g_costs[neighbor]:\n                best_g_costs[neighbor] = tentative_g\n                h_cost = heuristic_func(neighbor)\n                f_cost = tentative_g + h_cost\n                new_path = path + [neighbor]\n                heapq.heappush(open_set, (f_cost, neighbor, new_path, tentative_g))\n    \n    return None\n\n# Example usage and testing\nif __name__ == \"__main__\":\n    # Example grid (0 = walkable, 1 = obstacle)\n    grid = [\n        [0, 0, 0, 0, 1, 0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 1, 0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 1, 0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 1, 0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 1, 0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 1, 0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 1, 0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 1, 0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n    ]\n    \n    start = (0, 0)\n    goal = (9, 9)\n    \n    # Test different heuristics\n    heuristics = {\n        \"Manhattan\": manhattan_distance,\n        \"Euclidean\": euclidean_distance,\n        \"Diagonal\": diagonal_distance\n    }\n    \n    for name, heuristic in heuristics.items():\n        print(f\"\\nUsing {name} heuristic:\")\n        path = astar_search(grid, start, goal, heuristic, allow_diagonal=True)\n        \n        if path:\n            print(f\"Path found with {len(path)} steps:\")\n            print(f\"Path: {path[:5]}...{path[-5:] if len(path) > 10 else path[5:]}\")\n        else:\n            print(\"No path found!\")\n    \n    # Example with weighted graph\n    print(\"\\nWeighted graph example:\")\n    weighted_graph = {\n        'A': {'B': 4, 'C': 2},\n        'B': {'C': 1, 'D': 5},\n        'C': {'D': 8, 'E': 10},\n        'D': {'E': 2},\n        'E': {}\n    }\n    \n    # Simple heuristic for demonstration\n    def simple_heuristic(node):\n        heuristic_values = {'A': 7, 'B': 6, 'C': 4, 'D': 2, 'E': 0}\n        return heuristic_values.get(node, 0)\n    \n    result = astar_with_weights(weighted_graph, 'A', 'E', simple_heuristic)\n    if result:\n        path, cost = result\n        print(f\"Path: {' -> '.join(path)}\")\n        print(f\"Total cost: {cost}\")\n    else:\n        print(\"No path found!\")",
        "java": "// Java A* Search Algorithm Implementation\nimport java.util.*;\n\npublic class AStarSearch {\n    \n    static class Node implements Comparable<Node> {\n        int x, y;\n        double gCost, hCost, fCost;\n        Node parent;\n        \n        public Node(int x, int y) {\n            this.x = x;\n            this.y = y;\n            this.gCost = 0;\n            this.hCost = 0;\n            this.fCost = 0;\n            this.parent = null;\n        }\n        \n        public Node(int x, int y, double gCost, double hCost, Node parent) {\n            this.x = x;\n            this.y = y;\n            this.gCost = gCost;\n            this.hCost = hCost;\n            this.fCost = gCost + hCost;\n            this.parent = parent;\n        }\n        \n        @Override\n        public int compareTo(Node other) {\n            return Double.compare(this.fCost, other.fCost);\n        }\n        \n        @Override\n        public boolean equals(Object obj) {\n            if (this == obj) return true;\n            if (obj == null || getClass() != obj.getClass()) return false;\n            Node node = (Node) obj;\n            return x == node.x && y == node.y;\n        }\n        \n        @Override\n        public int hashCode() {\n            return Objects.hash(x, y);\n        }\n    }\n    \n    // Heuristic functions\n    public static double manhattanDistance(int x1, int y1, int x2, int y2) {\n        return Math.abs(x1 - x2) + Math.abs(y1 - y2);\n    }\n    \n    public static double euclideanDistance(int x1, int y1, int x2, int y2) {\n        return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));\n    }\n    \n    public static double diagonalDistance(int x1, int y1, int x2, int y2) {\n        return Math.max(Math.abs(x1 - x2), Math.abs(y1 - y2));\n    }\n    \n    public static List<Node> findPath(int[][] grid, Node start, Node goal, \n                                     boolean allowDiagonal, String heuristicType) {\n        if (grid == null || grid.length == 0 || grid[0].length == 0) {\n            return null;\n        }\n        \n        int rows = grid.length;\n        int cols = grid[0].length;\n        \n        // Check if start and goal are valid\n        if (!isValid(grid, start.x, start.y) || !isValid(grid, goal.x, goal.y)) {\n            return null;\n        }\n        \n        // Define possible movements\n        int[][] movements;\n        double[] moveCosts;\n        \n        if (allowDiagonal) {\n            movements = new int[][]{{-1, -1}, {-1, 0}, {-1, 1}, {0, -1}, \n                                   {0, 1}, {1, -1}, {1, 0}, {1, 1}};\n            moveCosts = new double[]{1.414, 1, 1.414, 1, 1, 1.414, 1, 1.414};\n        } else {\n            movements = new int[][]{{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n            moveCosts = new double[]{1, 1, 1, 1};\n        }\n        \n        PriorityQueue<Node> openSet = new PriorityQueue<>();\n        Set<String> closedSet = new HashSet<>();\n        Map<String, Double> gCosts = new HashMap<>();\n        \n        // Calculate initial heuristic\n        double initialH = calculateHeuristic(start.x, start.y, goal.x, goal.y, heuristicType);\n        start.hCost = initialH;\n        start.fCost = start.gCost + start.hCost;\n        \n        openSet.offer(start);\n        gCosts.put(getKey(start.x, start.y), 0.0);\n        \n        while (!openSet.isEmpty()) {\n            Node current = openSet.poll();\n            String currentKey = getKey(current.x, current.y);\n            \n            // Check if we reached the goal\n            if (current.x == goal.x && current.y == goal.y) {\n                return reconstructPath(current);\n            }\n            \n            closedSet.add(currentKey);\n            \n            // Explore neighbors\n            for (int i = 0; i < movements.length; i++) {\n                int newX = current.x + movements[i][0];\n                int newY = current.y + movements[i][1];\n                String neighborKey = getKey(newX, newY);\n                \n                // Check bounds and obstacles\n                if (!isValid(grid, newX, newY) || closedSet.contains(neighborKey)) {\n                    continue;\n                }\n                \n                double tentativeG = current.gCost + moveCosts[i];\n                \n                if (!gCosts.containsKey(neighborKey) || tentativeG < gCosts.get(neighborKey)) {\n                    gCosts.put(neighborKey, tentativeG);\n                    double hCost = calculateHeuristic(newX, newY, goal.x, goal.y, heuristicType);\n                    Node neighbor = new Node(newX, newY, tentativeG, hCost, current);\n                    openSet.offer(neighbor);\n                }\n            }\n        }\n        \n        return null; // No path found\n    }\n    \n    private static boolean isValid(int[][] grid, int x, int y) {\n        return x >= 0 && x < grid.length && y >= 0 && y < grid[0].length && grid[x][y] == 0;\n    }\n    \n    private static String getKey(int x, int y) {\n        return x + \",\" + y;\n    }\n    \n    private static double calculateHeuristic(int x1, int y1, int x2, int y2, String type) {\n        switch (type.toLowerCase()) {\n            case \"euclidean\":\n                return euclideanDistance(x1, y1, x2, y2);\n            case \"diagonal\":\n                return diagonalDistance(x1, y1, x2, y2);\n            default:\n                return manhattanDistance(x1, y1, x2, y2);\n        }\n    }\n    \n    private static List<Node> reconstructPath(Node goalNode) {\n        List<Node> path = new ArrayList<>();\n        Node current = goalNode;\n        \n        while (current != null) {\n            path.add(current);\n            current = current.parent;\n        }\n        \n        Collections.reverse(path);\n        return path;\n    }\n    \n    // Weighted graph version\n    public static class WeightedGraph {\n        private Map<String, Map<String, Double>> graph;\n        private Map<String, Double> heuristics;\n        \n        public WeightedGraph() {\n            this.graph = new HashMap<>();\n            this.heuristics = new HashMap<>();\n        }\n        \n        public void addEdge(String from, String to, double weight) {\n            graph.computeIfAbsent(from, k -> new HashMap<>()).put(to, weight);\n        }\n        \n        public void setHeuristic(String node, double heuristic) {\n            heuristics.put(node, heuristic);\n        }\n        \n        public List<String> findPath(String start, String goal) {\n            PriorityQueue<WeightedNode> openSet = new PriorityQueue<>();\n            Set<String> closedSet = new HashSet<>();\n            Map<String, Double> gCosts = new HashMap<>();\n            \n            openSet.offer(new WeightedNode(start, 0, heuristics.getOrDefault(start, 0.0), null));\n            gCosts.put(start, 0.0);\n            \n            while (!openSet.isEmpty()) {\n                WeightedNode current = openSet.poll();\n                \n                if (current.name.equals(goal)) {\n                    return reconstructWeightedPath(current);\n                }\n                \n                if (closedSet.contains(current.name)) {\n                    continue;\n                }\n                \n                closedSet.add(current.name);\n                \n                Map<String, Double> neighbors = graph.getOrDefault(current.name, new HashMap<>());\n                for (Map.Entry<String, Double> neighbor : neighbors.entrySet()) {\n                    String neighborName = neighbor.getKey();\n                    double weight = neighbor.getValue();\n                    \n                    if (closedSet.contains(neighborName)) {\n                        continue;\n                    }\n                    \n                    double tentativeG = current.gCost + weight;\n                    \n                    if (!gCosts.containsKey(neighborName) || tentativeG < gCosts.get(neighborName)) {\n                        gCosts.put(neighborName, tentativeG);\n                        double hCost = heuristics.getOrDefault(neighborName, 0.0);\n                        openSet.offer(new WeightedNode(neighborName, tentativeG, hCost, current));\n                    }\n                }\n            }\n            \n            return null;\n        }\n        \n        private List<String> reconstructWeightedPath(WeightedNode goalNode) {\n            List<String> path = new ArrayList<>();\n            WeightedNode current = goalNode;\n            \n            while (current != null) {\n                path.add(current.name);\n                current = current.parent;\n            }\n            \n            Collections.reverse(path);\n            return path;\n        }\n    }\n    \n    static class WeightedNode implements Comparable<WeightedNode> {\n        String name;\n        double gCost, hCost, fCost;\n        WeightedNode parent;\n        \n        public WeightedNode(String name, double gCost, double hCost, WeightedNode parent) {\n            this.name = name;\n            this.gCost = gCost;\n            this.hCost = hCost;\n            this.fCost = gCost + hCost;\n            this.parent = parent;\n        }\n        \n        @Override\n        public int compareTo(WeightedNode other) {\n            return Double.compare(this.fCost, other.fCost);\n        }\n    }\n    \n    // Example usage\n    public static void main(String[] args) {\n        // Example grid\n        int[][] grid = {\n            {0, 0, 0, 0, 1, 0, 0, 0, 0, 0},\n            {0, 0, 0, 0, 1, 0, 0, 0, 0, 0},\n            {0, 0, 0, 0, 1, 0, 0, 0, 0, 0},\n            {0, 0, 0, 0, 1, 0, 0, 0, 0, 0},\n            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},\n            {0, 0, 0, 0, 1, 0, 0, 0, 0, 0},\n            {0, 0, 0, 0, 1, 0, 0, 0, 0, 0},\n            {0, 0, 0, 0, 1, 0, 0, 0, 0, 0},\n            {0, 0, 0, 0, 1, 0, 0, 0, 0, 0},\n            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}\n        };\n        \n        Node start = new Node(0, 0);\n        Node goal = new Node(9, 9);\n        \n        String[] heuristics = {\"manhattan\", \"euclidean\", \"diagonal\"};\n        \n        for (String heuristic : heuristics) {\n            System.out.println(\"\\nUsing \" + heuristic + \" heuristic:\");\n            List<Node> path = findPath(grid, start, goal, true, heuristic);\n            \n            if (path != null) {\n                System.out.println(\"Path found with \" + path.size() + \" steps\");\n                System.out.print(\"Path: \");\n                for (int i = 0; i < Math.min(5, path.size()); i++) {\n                    Node node = path.get(i);\n                    System.out.print(\"(\" + node.x + \",\" + node.y + \") \");\n                }\n                if (path.size() > 5) {\n                    System.out.print(\"... \");\n                    for (int i = Math.max(5, path.size() - 5); i < path.size(); i++) {\n                        Node node = path.get(i);\n                        System.out.print(\"(\" + node.x + \",\" + node.y + \") \");\n                    }\n                }\n                System.out.println();\n            } else {\n                System.out.println(\"No path found!\");\n            }\n        }\n    }\n}",
        "csharp": "// C# A* Search Algorithm Implementation\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic class AStarSearch\n{\n    public class Node : IComparable<Node>\n    {\n        public int X { get; set; }\n        public int Y { get; set; }\n        public double GCost { get; set; }\n        public double HCost { get; set; }\n        public double FCost => GCost + HCost;\n        public Node Parent { get; set; }\n        \n        public Node(int x, int y, double gCost = 0, double hCost = 0, Node parent = null)\n        {\n            X = x;\n            Y = y;\n            GCost = gCost;\n            HCost = hCost;\n            Parent = parent;\n        }\n        \n        public int CompareTo(Node other)\n        {\n            return FCost.CompareTo(other.FCost);\n        }\n        \n        public override bool Equals(object obj)\n        {\n            if (obj is Node other)\n                return X == other.X && Y == other.Y;\n            return false;\n        }\n        \n        public override int GetHashCode()\n        {\n            return HashCode.Combine(X, Y);\n        }\n    }\n    \n    // Heuristic functions\n    public static double ManhattanDistance(int x1, int y1, int x2, int y2)\n    {\n        return Math.Abs(x1 - x2) + Math.Abs(y1 - y2);\n    }\n    \n    public static double EuclideanDistance(int x1, int y1, int x2, int y2)\n    {\n        return Math.Sqrt(Math.Pow(x1 - x2, 2) + Math.Pow(y1 - y2, 2));\n    }\n    \n    public static double DiagonalDistance(int x1, int y1, int x2, int y2)\n    {\n        return Math.Max(Math.Abs(x1 - x2), Math.Abs(y1 - y2));\n    }\n    \n    public static List<Node> FindPath(int[,] grid, Node start, Node goal, \n                                     bool allowDiagonal = false, string heuristicType = \"manhattan\")\n    {\n        if (grid == null || grid.GetLength(0) == 0 || grid.GetLength(1) == 0)\n            return null;\n        \n        int rows = grid.GetLength(0);\n        int cols = grid.GetLength(1);\n        \n        // Check if start and goal are valid\n        if (!IsValid(grid, start.X, start.Y) || !IsValid(grid, goal.X, goal.Y))\n            return null;\n        \n        // Define possible movements\n        (int dx, int dy)[] movements;\n        double[] moveCosts;\n        \n        if (allowDiagonal)\n        {\n            movements = new[] { (-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1) };\n            moveCosts = new[] { 1.414, 1, 1.414, 1, 1, 1.414, 1, 1.414 };\n        }\n        else\n        {\n            movements = new[] { (-1, 0), (1, 0), (0, -1), (0, 1) };\n            moveCosts = new[] { 1.0, 1.0, 1.0, 1.0 };\n        }\n        \n        var openSet = new SortedSet<Node>();\n        var closedSet = new HashSet<string>();\n        var gCosts = new Dictionary<string, double>();\n        \n        // Calculate initial heuristic\n        start.HCost = CalculateHeuristic(start.X, start.Y, goal.X, goal.Y, heuristicType);\n        \n        openSet.Add(start);\n        gCosts[GetKey(start.X, start.Y)] = 0;\n        \n        while (openSet.Count > 0)\n        {\n            var current = openSet.Min;\n            openSet.Remove(current);\n            \n            string currentKey = GetKey(current.X, current.Y);\n            \n            // Check if we reached the goal\n            if (current.X == goal.X && current.Y == goal.Y)\n            {\n                return ReconstructPath(current);\n            }\n            \n            closedSet.Add(currentKey);\n            \n            // Explore neighbors\n            for (int i = 0; i < movements.Length; i++)\n            {\n                int newX = current.X + movements[i].dx;\n                int newY = current.Y + movements[i].dy;\n                string neighborKey = GetKey(newX, newY);\n                \n                // Check bounds and obstacles\n                if (!IsValid(grid, newX, newY) || closedSet.Contains(neighborKey))\n                    continue;\n                \n                double tentativeG = current.GCost + moveCosts[i];\n                \n                if (!gCosts.ContainsKey(neighborKey) || tentativeG < gCosts[neighborKey])\n                {\n                    gCosts[neighborKey] = tentativeG;\n                    double hCost = CalculateHeuristic(newX, newY, goal.X, goal.Y, heuristicType);\n                    var neighbor = new Node(newX, newY, tentativeG, hCost, current);\n                    openSet.Add(neighbor);\n                }\n            }\n        }\n        \n        return null; // No path found\n    }\n    \n    private static bool IsValid(int[,] grid, int x, int y)\n    {\n        return x >= 0 && x < grid.GetLength(0) && y >= 0 && y < grid.GetLength(1) && grid[x, y] == 0;\n    }\n    \n    private static string GetKey(int x, int y)\n    {\n        return $\"{x},{y}\";\n    }\n    \n    private static double CalculateHeuristic(int x1, int y1, int x2, int y2, string type)\n    {\n        return type.ToLower() switch\n        {\n            \"euclidean\" => EuclideanDistance(x1, y1, x2, y2),\n            \"diagonal\" => DiagonalDistance(x1, y1, x2, y2),\n            _ => ManhattanDistance(x1, y1, x2, y2)\n        };\n    }\n    \n    private static List<Node> ReconstructPath(Node goalNode)\n    {\n        var path = new List<Node>();\n        var current = goalNode;\n        \n        while (current != null)\n        {\n            path.Add(current);\n            current = current.Parent;\n        }\n        \n        path.Reverse();\n        return path;\n    }\n    \n    // Weighted graph version\n    public class WeightedGraph\n    {\n        private Dictionary<string, Dictionary<string, double>> graph;\n        private Dictionary<string, double> heuristics;\n        \n        public WeightedGraph()\n        {\n            graph = new Dictionary<string, Dictionary<string, double>>();\n            heuristics = new Dictionary<string, double>();\n        }\n        \n        public void AddEdge(string from, string to, double weight)\n        {\n            if (!graph.ContainsKey(from))\n                graph[from] = new Dictionary<string, double>();\n            graph[from][to] = weight;\n        }\n        \n        public void SetHeuristic(string node, double heuristic)\n        {\n            heuristics[node] = heuristic;\n        }\n        \n        public List<string> FindPath(string start, string goal)\n        {\n            var openSet = new SortedSet<WeightedNode>();\n            var closedSet = new HashSet<string>();\n            var gCosts = new Dictionary<string, double>();\n            \n            openSet.Add(new WeightedNode(start, 0, heuristics.GetValueOrDefault(start, 0), null));\n            gCosts[start] = 0;\n            \n            while (openSet.Count > 0)\n            {\n                var current = openSet.Min;\n                openSet.Remove(current);\n                \n                if (current.Name == goal)\n                {\n                    return ReconstructWeightedPath(current);\n                }\n                \n                if (closedSet.Contains(current.Name))\n                    continue;\n                \n                closedSet.Add(current.Name);\n                \n                if (graph.ContainsKey(current.Name))\n                {\n                    foreach (var neighbor in graph[current.Name])\n                    {\n                        string neighborName = neighbor.Key;\n                        double weight = neighbor.Value;\n                        \n                        if (closedSet.Contains(neighborName))\n                            continue;\n                        \n                        double tentativeG = current.GCost + weight;\n                        \n                        if (!gCosts.ContainsKey(neighborName) || tentativeG < gCosts[neighborName])\n                        {\n                            gCosts[neighborName] = tentativeG;\n                            double hCost = heuristics.GetValueOrDefault(neighborName, 0);\n                            openSet.Add(new WeightedNode(neighborName, tentativeG, hCost, current));\n                        }\n                    }\n                }\n            }\n            \n            return null;\n        }\n        \n        private List<string> ReconstructWeightedPath(WeightedNode goalNode)\n        {\n            var path = new List<string>();\n            var current = goalNode;\n            \n            while (current != null)\n            {\n                path.Add(current.Name);\n                current = current.Parent;\n            }\n            \n            path.Reverse();\n            return path;\n        }\n    }\n    \n    public class WeightedNode : IComparable<WeightedNode>\n    {\n        public string Name { get; set; }\n        public double GCost { get; set; }\n        public double HCost { get; set; }\n        public double FCost => GCost + HCost;\n        public WeightedNode Parent { get; set; }\n        \n        public WeightedNode(string name, double gCost, double hCost, WeightedNode parent)\n        {\n            Name = name;\n            GCost = gCost;\n            HCost = hCost;\n            Parent = parent;\n        }\n        \n        public int CompareTo(WeightedNode other)\n        {\n            int result = FCost.CompareTo(other.FCost);\n            return result == 0 ? Name.CompareTo(other.Name) : result;\n        }\n    }\n    \n    // Example usage\n    static void Main(string[] args)\n    {\n        // Example grid\n        int[,] grid = {\n            {0, 0, 0, 0, 1, 0, 0, 0, 0, 0},\n            {0, 0, 0, 0, 1, 0, 0, 0, 0, 0},\n            {0, 0, 0, 0, 1, 0, 0, 0, 0, 0},\n            {0, 0, 0, 0, 1, 0, 0, 0, 0, 0},\n            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},\n            {0, 0, 0, 0, 1, 0, 0, 0, 0, 0},\n            {0, 0, 0, 0, 1, 0, 0, 0, 0, 0},\n            {0, 0, 0, 0, 1, 0, 0, 0, 0, 0},\n            {0, 0, 0, 0, 1, 0, 0, 0, 0, 0},\n            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}\n        };\n        \n        var start = new Node(0, 0);\n        var goal = new Node(9, 9);\n        \n        string[] heuristics = { \"manhattan\", \"euclidean\", \"diagonal\" };\n        \n        foreach (string heuristic in heuristics)\n        {\n            Console.WriteLine($\"\\nUsing {heuristic} heuristic:\");\n            var path = FindPath(grid, start, goal, true, heuristic);\n            \n            if (path != null)\n            {\n                Console.WriteLine($\"Path found with {path.Count} steps\");\n                Console.Write(\"Path: \");\n                for (int i = 0; i < Math.Min(5, path.Count); i++)\n                {\n                    var node = path[i];\n                    Console.Write($\"({node.X},{node.Y}) \");\n                }\n                if (path.Count > 5)\n                {\n                    Console.Write(\"... \");\n                    for (int i = Math.Max(5, path.Count - 5); i < path.Count; i++)\n                    {\n                        var node = path[i];\n                        Console.Write($\"({node.X},{node.Y}) \");\n                    }\n                }\n                Console.WriteLine();\n            }\n            else\n            {\n                Console.WriteLine(\"No path found!\");\n            }\n        }\n    }\n}"
      }
    },
    {
      "id": 16,
      "name": "Longest Common Subsequence (LCS)",
      "category": "Dynamic Programming",
      "description": "A dynamic programming algorithm that finds the longest subsequence common to two sequences, widely used in bioinformatics and text comparison",
      "time_complexity": {
        "best": "O(m * n)",
        "average": "O(m * n)",
        "worst": "O(m * n)"
      },
      "space_complexity": "O(m * n)",
      "prerequisites": ["Dynamic programming basics", "2D array manipulation"],
      "use_cases": ["DNA sequence analysis", "File difference tools", "Version control systems", "Text similarity"],
      "implementations": {
        "python": "def longest_common_subsequence(text1, text2):\n    \"\"\"\n    Find the longest common subsequence between two strings\n    \"\"\"\n    m, n = len(text1), len(text2)\n    \n    # Create DP table\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    # Fill the DP table\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if text1[i - 1] == text2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    \n    return dp[m][n]\n\ndef lcs_with_sequence(text1, text2):\n    \"\"\"\n    Find LCS length and the actual subsequence\n    \"\"\"\n    m, n = len(text1), len(text2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    # Fill DP table\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if text1[i - 1] == text2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    \n    # Reconstruct the LCS\n    lcs = []\n    i, j = m, n\n    \n    while i > 0 and j > 0:\n        if text1[i - 1] == text2[j - 1]:\n            lcs.append(text1[i - 1])\n            i -= 1\n            j -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    \n    return dp[m][n], ''.join(reversed(lcs))\n\ndef lcs_space_optimized(text1, text2):\n    \"\"\"\n    Space-optimized version using only two rows\n    \"\"\"\n    m, n = len(text1), len(text2)\n    \n    # Use only two rows instead of full matrix\n    prev = [0] * (n + 1)\n    curr = [0] * (n + 1)\n    \n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if text1[i - 1] == text2[j - 1]:\n                curr[j] = prev[j - 1] + 1\n            else:\n                curr[j] = max(prev[j], curr[j - 1])\n        \n        # Swap rows\n        prev, curr = curr, prev\n    \n    return prev[n]\n\ndef lcs_multiple_sequences(*sequences):\n    \"\"\"\n    Find LCS of multiple sequences (3 or more)\n    \"\"\"\n    if len(sequences) < 2:\n        return 0 if len(sequences) == 0 else len(sequences[0])\n    \n    if len(sequences) == 2:\n        return longest_common_subsequence(sequences[0], sequences[1])\n    \n    # For multiple sequences, use recursive approach\n    def lcs_recursive(seqs, lengths, indices):\n        # Check if any sequence is exhausted\n        for i, seq in enumerate(seqs):\n            if indices[i] >= lengths[i]:\n                return 0\n        \n        # Check if all current characters are the same\n        first_char = seqs[0][indices[0]]\n        all_same = all(seqs[i][indices[i]] == first_char for i in range(len(seqs)))\n        \n        if all_same:\n            # Include this character and move all indices\n            new_indices = [idx + 1 for idx in indices]\n            return 1 + lcs_recursive(seqs, lengths, new_indices)\n        else:\n            # Try advancing each sequence one by one and take maximum\n            max_length = 0\n            for i in range(len(seqs)):\n                new_indices = indices[:]\n                new_indices[i] += 1\n                max_length = max(max_length, lcs_recursive(seqs, lengths, new_indices))\n            return max_length\n    \n    lengths = [len(seq) for seq in sequences]\n    indices = [0] * len(sequences)\n    return lcs_recursive(sequences, lengths, indices)\n\n# Example usage and testing\nif __name__ == \"__main__\":\n    # Test basic LCS\n    text1 = \"ABCDGH\"\n    text2 = \"AEDFHR\"\n    \n    length = longest_common_subsequence(text1, text2)\n    print(f\"LCS length: {length}\")  # Output: 3\n    \n    length, sequence = lcs_with_sequence(text1, text2)\n    print(f\"LCS: '{sequence}' (length: {length})\")  # Output: ADH\n    \n    # Test space-optimized version\n    length_opt = lcs_space_optimized(text1, text2)\n    print(f\"Space-optimized LCS length: {length_opt}\")\n    \n    # Test with DNA sequences\n    dna1 = \"AGGTAB\"\n    dna2 = \"GXTXAYB\"\n    length, sequence = lcs_with_sequence(dna1, dna2)\n    print(f\"DNA LCS: '{sequence}' (length: {length})\")\n    \n    # Test multiple sequences\n    seq1, seq2, seq3 = \"ABCD\", \"ACBD\", \"ABDC\"\n    multi_lcs = lcs_multiple_sequences(seq1, seq2, seq3)\n    print(f\"Multiple sequences LCS length: {multi_lcs}\")",
        "java": "// Java LCS Implementation\npublic class LongestCommonSubsequence {\n    \n    public static int longestCommonSubsequence(String text1, String text2) {\n        int m = text1.length();\n        int n = text2.length();\n        \n        // Create DP table\n        int[][] dp = new int[m + 1][n + 1];\n        \n        // Fill the DP table\n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                if (text1.charAt(i - 1) == text2.charAt(j - 1)) {\n                    dp[i][j] = dp[i - 1][j - 1] + 1;\n                } else {\n                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\n                }\n            }\n        }\n        \n        return dp[m][n];\n    }\n    \n    public static class LCSResult {\n        public int length;\n        public String sequence;\n        \n        public LCSResult(int length, String sequence) {\n            this.length = length;\n            this.sequence = sequence;\n        }\n    }\n    \n    public static LCSResult lcsWithSequence(String text1, String text2) {\n        int m = text1.length();\n        int n = text2.length();\n        int[][] dp = new int[m + 1][n + 1];\n        \n        // Fill DP table\n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                if (text1.charAt(i - 1) == text2.charAt(j - 1)) {\n                    dp[i][j] = dp[i - 1][j - 1] + 1;\n                } else {\n                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\n                }\n            }\n        }\n        \n        // Reconstruct the LCS\n        StringBuilder lcs = new StringBuilder();\n        int i = m, j = n;\n        \n        while (i > 0 && j > 0) {\n            if (text1.charAt(i - 1) == text2.charAt(j - 1)) {\n                lcs.append(text1.charAt(i - 1));\n                i--;\n                j--;\n            } else if (dp[i - 1][j] > dp[i][j - 1]) {\n                i--;\n            } else {\n                j--;\n            }\n        }\n        \n        return new LCSResult(dp[m][n], lcs.reverse().toString());\n    }\n    \n    public static int lcsSpaceOptimized(String text1, String text2) {\n        int m = text1.length();\n        int n = text2.length();\n        \n        // Use only two rows instead of full matrix\n        int[] prev = new int[n + 1];\n        int[] curr = new int[n + 1];\n        \n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                if (text1.charAt(i - 1) == text2.charAt(j - 1)) {\n                    curr[j] = prev[j - 1] + 1;\n                } else {\n                    curr[j] = Math.max(prev[j], curr[j - 1]);\n                }\n            }\n            \n            // Swap arrays\n            int[] temp = prev;\n            prev = curr;\n            curr = temp;\n            java.util.Arrays.fill(curr, 0);\n        }\n        \n        return prev[n];\n    }\n    \n    // Memoized recursive approach\n    public static int lcsRecursive(String text1, String text2) {\n        int[][] memo = new int[text1.length()][text2.length()];\n        for (int[] row : memo) {\n            java.util.Arrays.fill(row, -1);\n        }\n        return lcsRecursiveHelper(text1, text2, 0, 0, memo);\n    }\n    \n    private static int lcsRecursiveHelper(String text1, String text2, int i, int j, int[][] memo) {\n        if (i >= text1.length() || j >= text2.length()) {\n            return 0;\n        }\n        \n        if (memo[i][j] != -1) {\n            return memo[i][j];\n        }\n        \n        if (text1.charAt(i) == text2.charAt(j)) {\n            memo[i][j] = 1 + lcsRecursiveHelper(text1, text2, i + 1, j + 1, memo);\n        } else {\n            memo[i][j] = Math.max(\n                lcsRecursiveHelper(text1, text2, i + 1, j, memo),\n                lcsRecursiveHelper(text1, text2, i, j + 1, memo)\n            );\n        }\n        \n        return memo[i][j];\n    }\n    \n    // Find all LCS sequences\n    public static java.util.Set<String> findAllLCS(String text1, String text2) {\n        int m = text1.length();\n        int n = text2.length();\n        int[][] dp = new int[m + 1][n + 1];\n        \n        // Fill DP table\n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                if (text1.charAt(i - 1) == text2.charAt(j - 1)) {\n                    dp[i][j] = dp[i - 1][j - 1] + 1;\n                } else {\n                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\n                }\n            }\n        }\n        \n        java.util.Set<String> result = new java.util.HashSet<>();\n        findAllLCSHelper(text1, text2, m, n, dp, \"\", result);\n        return result;\n    }\n    \n    private static void findAllLCSHelper(String text1, String text2, int i, int j, \n                                        int[][] dp, String current, java.util.Set<String> result) {\n        if (i == 0 || j == 0) {\n            result.add(new StringBuilder(current).reverse().toString());\n            return;\n        }\n        \n        if (text1.charAt(i - 1) == text2.charAt(j - 1)) {\n            findAllLCSHelper(text1, text2, i - 1, j - 1, dp, \n                           current + text1.charAt(i - 1), result);\n        } else {\n            if (dp[i - 1][j] == dp[i][j]) {\n                findAllLCSHelper(text1, text2, i - 1, j, dp, current, result);\n            }\n            if (dp[i][j - 1] == dp[i][j]) {\n                findAllLCSHelper(text1, text2, i, j - 1, dp, current, result);\n            }\n        }\n    }\n    \n    // Example usage\n    public static void main(String[] args) {\n        String text1 = \"ABCDGH\";\n        String text2 = \"AEDFHR\";\n        \n        int length = longestCommonSubsequence(text1, text2);\n        System.out.println(\"LCS length: \" + length);\n        \n        LCSResult result = lcsWithSequence(text1, text2);\n        System.out.println(\"LCS: '\" + result.sequence + \"' (length: \" + result.length + \")\");\n        \n        int lengthOpt = lcsSpaceOptimized(text1, text2);\n        System.out.println(\"Space-optimized LCS length: \" + lengthOpt);\n        \n        // Test with DNA sequences\n        String dna1 = \"AGGTAB\";\n        String dna2 = \"GXTXAYB\";\n        LCSResult dnaResult = lcsWithSequence(dna1, dna2);\n        System.out.println(\"DNA LCS: '\" + dnaResult.sequence + \"' (length: \" + dnaResult.length + \")\");\n        \n        // Find all possible LCS\n        java.util.Set<String> allLCS = findAllLCS(\"ABC\", \"AC\");\n        System.out.println(\"All LCS: \" + allLCS);\n    }\n}",
        "csharp": "// C# LCS Implementation\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\npublic class LongestCommonSubsequence\n{\n    public static int FindLCS(string text1, string text2)\n    {\n        int m = text1.Length;\n        int n = text2.Length;\n        \n        // Create DP table\n        int[,] dp = new int[m + 1, n + 1];\n        \n        // Fill the DP table\n        for (int i = 1; i <= m; i++)\n        {\n            for (int j = 1; j <= n; j++)\n            {\n                if (text1[i - 1] == text2[j - 1])\n                {\n                    dp[i, j] = dp[i - 1, j - 1] + 1;\n                }\n                else\n                {\n                    dp[i, j] = Math.Max(dp[i - 1, j], dp[i, j - 1]);\n                }\n            }\n        }\n        \n        return dp[m, n];\n    }\n    \n    public class LCSResult\n    {\n        public int Length { get; set; }\n        public string Sequence { get; set; }\n        \n        public LCSResult(int length, string sequence)\n        {\n            Length = length;\n            Sequence = sequence;\n        }\n    }\n    \n    public static LCSResult FindLCSWithSequence(string text1, string text2)\n    {\n        int m = text1.Length;\n        int n = text2.Length;\n        int[,] dp = new int[m + 1, n + 1];\n        \n        // Fill DP table\n        for (int i = 1; i <= m; i++)\n        {\n            for (int j = 1; j <= n; j++)\n            {\n                if (text1[i - 1] == text2[j - 1])\n                {\n                    dp[i, j] = dp[i - 1, j - 1] + 1;\n                }\n                else\n                {\n                    dp[i, j] = Math.Max(dp[i - 1, j], dp[i, j - 1]);\n                }\n            }\n        }\n        \n        // Reconstruct the LCS\n        var lcs = new StringBuilder();\n        int x = m, y = n;\n        \n        while (x > 0 && y > 0)\n        {\n            if (text1[x - 1] == text2[y - 1])\n            {\n                lcs.Append(text1[x - 1]);\n                x--;\n                y--;\n            }\n            else if (dp[x - 1, y] > dp[x, y - 1])\n            {\n                x--;\n            }\n            else\n            {\n                y--;\n            }\n        }\n        \n        // Reverse the string since we built it backwards\n        var sequence = new string(lcs.ToString().Reverse().ToArray());\n        return new LCSResult(dp[m, n], sequence);\n    }\n    \n    public static int FindLCSSpaceOptimized(string text1, string text2)\n    {\n        int m = text1.Length;\n        int n = text2.Length;\n        \n        // Use only two rows instead of full matrix\n        int[] prev = new int[n + 1];\n        int[] curr = new int[n + 1];\n        \n        for (int i = 1; i <= m; i++)\n        {\n            for (int j = 1; j <= n; j++)\n            {\n                if (text1[i - 1] == text2[j - 1])\n                {\n                    curr[j] = prev[j - 1] + 1;\n                }\n                else\n                {\n                    curr[j] = Math.Max(prev[j], curr[j - 1]);\n                }\n            }\n            \n            // Swap arrays\n            (prev, curr) = (curr, prev);\n            Array.Clear(curr, 0, curr.Length);\n        }\n        \n        return prev[n];\n    }\n    \n    // Memoized recursive approach\n    public static int FindLCSRecursive(string text1, string text2)\n    {\n        var memo = new Dictionary<(int, int), int>();\n        return FindLCSRecursiveHelper(text1, text2, 0, 0, memo);\n    }\n    \n    private static int FindLCSRecursiveHelper(string text1, string text2, int i, int j, \n                                            Dictionary<(int, int), int> memo)\n    {\n        if (i >= text1.Length || j >= text2.Length)\n        {\n            return 0;\n        }\n        \n        if (memo.ContainsKey((i, j)))\n        {\n            return memo[(i, j)];\n        }\n        \n        int result;\n        if (text1[i] == text2[j])\n        {\n            result = 1 + FindLCSRecursiveHelper(text1, text2, i + 1, j + 1, memo);\n        }\n        else\n        {\n            result = Math.Max(\n                FindLCSRecursiveHelper(text1, text2, i + 1, j, memo),\n                FindLCSRecursiveHelper(text1, text2, i, j + 1, memo)\n            );\n        }\n        \n        memo[(i, j)] = result;\n        return result;\n    }\n    \n    // Find all possible LCS sequences\n    public static HashSet<string> FindAllLCS(string text1, string text2)\n    {\n        int m = text1.Length;\n        int n = text2.Length;\n        int[,] dp = new int[m + 1, n + 1];\n        \n        // Fill DP table\n        for (int i = 1; i <= m; i++)\n        {\n            for (int j = 1; j <= n; j++)\n            {\n                if (text1[i - 1] == text2[j - 1])\n                {\n                    dp[i, j] = dp[i - 1, j - 1] + 1;\n                }\n                else\n                {\n                    dp[i, j] = Math.Max(dp[i - 1, j], dp[i, j - 1]);\n                }\n            }\n        }\n        \n        var result = new HashSet<string>();\n        FindAllLCSHelper(text1, text2, m, n, dp, \"\", result);\n        return result;\n    }\n    \n    private static void FindAllLCSHelper(string text1, string text2, int i, int j, \n                                       int[,] dp, string current, HashSet<string> result)\n    {\n        if (i == 0 || j == 0)\n        {\n            result.Add(new string(current.Reverse().ToArray()));\n            return;\n        }\n        \n        if (text1[i - 1] == text2[j - 1])\n        {\n            FindAllLCSHelper(text1, text2, i - 1, j - 1, dp, \n                           current + text1[i - 1], result);\n        }\n        else\n        {\n            if (dp[i - 1, j] == dp[i, j])\n            {\n                FindAllLCSHelper(text1, text2, i - 1, j, dp, current, result);\n            }\n            if (dp[i, j - 1] == dp[i, j])\n            {\n                FindAllLCSHelper(text1, text2, i, j - 1, dp, current, result);\n            }\n        }\n    }\n    \n    // Similarity percentage based on LCS\n    public static double CalculateSimilarity(string text1, string text2)\n    {\n        if (string.IsNullOrEmpty(text1) && string.IsNullOrEmpty(text2))\n            return 100.0;\n        \n        if (string.IsNullOrEmpty(text1) || string.IsNullOrEmpty(text2))\n            return 0.0;\n        \n        int lcsLength = FindLCS(text1, text2);\n        int maxLength = Math.Max(text1.Length, text2.Length);\n        \n        return (double)lcsLength / maxLength * 100.0;\n    }\n    \n    // Example usage\n    static void Main(string[] args)\n    {\n        string text1 = \"ABCDGH\";\n        string text2 = \"AEDFHR\";\n        \n        int length = FindLCS(text1, text2);\n        Console.WriteLine($\"LCS length: {length}\");\n        \n        var result = FindLCSWithSequence(text1, text2);\n        Console.WriteLine($\"LCS: '{result.Sequence}' (length: {result.Length})\");\n        \n        int lengthOpt = FindLCSSpaceOptimized(text1, text2);\n        Console.WriteLine($\"Space-optimized LCS length: {lengthOpt}\");\n        \n        // Test with DNA sequences\n        string dna1 = \"AGGTAB\";\n        string dna2 = \"GXTXAYB\";\n        var dnaResult = FindLCSWithSequence(dna1, dna2);\n        Console.WriteLine($\"DNA LCS: '{dnaResult.Sequence}' (length: {dnaResult.Length})\");\n        \n        // Calculate similarity\n        double similarity = CalculateSimilarity(text1, text2);\n        Console.WriteLine($\"Similarity: {similarity:F1}%\");\n        \n        // Find all possible LCS\n        var allLCS = FindAllLCS(\"ABC\", \"AC\");\n        Console.WriteLine($\"All LCS: [{string.Join(\", \", allLCS.Select(s => $\"'{s}'\"))}]\");\n    }\n}"
      }
    },
    {
      "id": 17,
      "name": "Knapsack Problem",
      "category": "Dynamic Programming",
      "description": "A classic optimization problem that determines the most valuable combination of items to include in a knapsack with limited capacity",
      "time_complexity": {
        "best": "O(n * W)",
        "average": "O(n * W)",
        "worst": "O(n * W)"
      },
      "space_complexity": "O(n * W)",
      "prerequisites": ["Dynamic programming", "Optimization concepts"],
      "use_cases": ["Resource allocation", "Portfolio optimization", "Cargo loading", "Budget planning"],
      "implementations": {
        "python": "def knapsack_01(weights, values, capacity):\n    \"\"\"\n    0/1 Knapsack Problem - each item can be taken at most once\n    \"\"\"\n    n = len(weights)\n    \n    # Create DP table\n    dp = [[0 for _ in range(capacity + 1)] for _ in range(n + 1)]\n    \n    # Fill the DP table\n    for i in range(1, n + 1):\n        for w in range(1, capacity + 1):\n            # If current item's weight is more than capacity, skip it\n            if weights[i - 1] > w:\n                dp[i][w] = dp[i - 1][w]\n            else:\n                # Choose maximum of including or excluding current item\n                include = values[i - 1] + dp[i - 1][w - weights[i - 1]]\n                exclude = dp[i - 1][w]\n                dp[i][w] = max(include, exclude)\n    \n    return dp[n][capacity]\n\ndef knapsack_with_items(weights, values, capacity):\n    \"\"\"\n    0/1 Knapsack with item tracking\n    \"\"\"\n    n = len(weights)\n    dp = [[0 for _ in range(capacity + 1)] for _ in range(n + 1)]\n    \n    # Fill DP table\n    for i in range(1, n + 1):\n        for w in range(1, capacity + 1):\n            if weights[i - 1] > w:\n                dp[i][w] = dp[i - 1][w]\n            else:\n                include = values[i - 1] + dp[i - 1][w - weights[i - 1]]\n                exclude = dp[i - 1][w]\n                dp[i][w] = max(include, exclude)\n    \n    # Backtrack to find selected items\n    selected_items = []\n    w = capacity\n    \n    for i in range(n, 0, -1):\n        # If value comes from including current item\n        if dp[i][w] != dp[i - 1][w]:\n            selected_items.append(i - 1)  # Store 0-based index\n            w -= weights[i - 1]\n    \n    selected_items.reverse()\n    return dp[n][capacity], selected_items\n\ndef knapsack_space_optimized(weights, values, capacity):\n    \"\"\"\n    Space-optimized version using 1D array\n    \"\"\"\n    n = len(weights)\n    dp = [0] * (capacity + 1)\n    \n    for i in range(n):\n        # Traverse from right to left to avoid using updated values\n        for w in range(capacity, weights[i] - 1, -1):\n            dp[w] = max(dp[w], dp[w - weights[i]] + values[i])\n    \n    return dp[capacity]\n\ndef unbounded_knapsack(weights, values, capacity):\n    \"\"\"\n    Unbounded Knapsack - unlimited quantity of each item\n    \"\"\"\n    n = len(weights)\n    dp = [0] * (capacity + 1)\n    \n    for w in range(1, capacity + 1):\n        for i in range(n):\n            if weights[i] <= w:\n                dp[w] = max(dp[w], dp[w - weights[i]] + values[i])\n    \n    return dp[capacity]\n\ndef fractional_knapsack(weights, values, capacity):\n    \"\"\"\n    Fractional Knapsack - items can be broken into fractions\n    Uses greedy approach based on value-to-weight ratio\n    \"\"\"\n    n = len(weights)\n    \n    # Create list of (value/weight ratio, weight, value, index)\n    items = [(values[i] / weights[i], weights[i], values[i], i) \n             for i in range(n)]\n    \n    # Sort by value-to-weight ratio in descending order\n    items.sort(reverse=True)\n    \n    total_value = 0\n    selected_items = []\n    remaining_capacity = capacity\n    \n    for ratio, weight, value, index in items:\n        if remaining_capacity >= weight:\n            # Take the whole item\n            total_value += value\n            remaining_capacity -= weight\n            selected_items.append((index, 1.0))  # (item_index, fraction)\n        elif remaining_capacity > 0:\n            # Take fraction of the item\n            fraction = remaining_capacity / weight\n            total_value += value * fraction\n            selected_items.append((index, fraction))\n            remaining_capacity = 0\n            break\n    \n    return total_value, selected_items\n\ndef knapsack_multiple_constraints(weights, values, capacity, volumes, volume_limit):\n    \"\"\"\n    Knapsack with multiple constraints (weight and volume)\n    \"\"\"\n    n = len(weights)\n    \n    # 3D DP table: dp[i][w][v] = max value using first i items with weight w and volume v\n    dp = [[[0 for _ in range(volume_limit + 1)] \n           for _ in range(capacity + 1)] \n          for _ in range(n + 1)]\n    \n    for i in range(1, n + 1):\n        for w in range(capacity + 1):\n            for v in range(volume_limit + 1):\n                # Don't include current item\n                dp[i][w][v] = dp[i - 1][w][v]\n                \n                # Include current item if constraints allow\n                if weights[i - 1] <= w and volumes[i - 1] <= v:\n                    include_value = (values[i - 1] + \n                                   dp[i - 1][w - weights[i - 1]][v - volumes[i - 1]])\n                    dp[i][w][v] = max(dp[i][w][v], include_value)\n    \n    return dp[n][capacity][volume_limit]\n\ndef knapsack_with_dependencies(weights, values, capacity, dependencies):\n    \"\"\"\n    Knapsack with item dependencies\n    dependencies: list of (prerequisite_item, dependent_item) tuples\n    \"\"\"\n    n = len(weights)\n    \n    # Build dependency graph\n    prereq = {i: [] for i in range(n)}\n    for pre, dep in dependencies:\n        prereq[dep].append(pre)\n    \n    # Use bitmask DP where each bit represents whether an item is selected\n    dp = {}\n    \n    def solve(mask, remaining_capacity):\n        if (mask, remaining_capacity) in dp:\n            return dp[(mask, remaining_capacity)]\n        \n        max_value = 0\n        \n        for i in range(n):\n            # If item i is not selected and we have capacity\n            if not (mask & (1 << i)) and weights[i] <= remaining_capacity:\n                # Check if all prerequisites are satisfied\n                can_select = True\n                for prereq_item in prereq[i]:\n                    if not (mask & (1 << prereq_item)):\n                        can_select = False\n                        break\n                \n                if can_select:\n                    new_mask = mask | (1 << i)\n                    new_capacity = remaining_capacity - weights[i]\n                    value = values[i] + solve(new_mask, new_capacity)\n                    max_value = max(max_value, value)\n        \n        dp[(mask, remaining_capacity)] = max_value\n        return max_value\n    \n    return solve(0, capacity)\n\n# Example usage and testing\nif __name__ == \"__main__\":\n    # Test 0/1 Knapsack\n    weights = [10, 20, 30]\n    values = [60, 100, 120]\n    capacity = 50\n    \n    max_value = knapsack_01(weights, values, capacity)\n    print(f\"0/1 Knapsack max value: {max_value}\")  # Output: 220\n    \n    max_value, items = knapsack_with_items(weights, values, capacity)\n    print(f\"Selected items (0-based indices): {items}\")  # Output: [1, 2]\n    print(f\"Max value with items: {max_value}\")\n    \n    # Test space-optimized version\n    max_value_opt = knapsack_space_optimized(weights, values, capacity)\n    print(f\"Space-optimized max value: {max_value_opt}\")\n    \n    # Test unbounded knapsack\n    unbounded_value = unbounded_knapsack(weights, values, capacity)\n    print(f\"Unbounded knapsack max value: {unbounded_value}\")\n    \n    # Test fractional knapsack\n    frac_value, frac_items = fractional_knapsack(weights, values, capacity)\n    print(f\"Fractional knapsack max value: {frac_value:.2f}\")\n    print(f\"Fractional items: {frac_items}\")\n    \n    # Test multiple constraints\n    volumes = [5, 10, 15]\n    volume_limit = 25\n    multi_value = knapsack_multiple_constraints(weights, values, capacity, volumes, volume_limit)\n    print(f\"Multi-constraint knapsack max value: {multi_value}\")\n    \n    # Test with dependencies\n    dependencies = [(0, 1)]  # Item 1 depends on item 0\n    dep_value = knapsack_with_dependencies(weights, values, capacity, dependencies)\n    print(f\"Knapsack with dependencies max value: {dep_value}\")",
        "java": "// Java Knapsack Implementation\nimport java.util.*;\n\npublic class KnapsackProblem {\n    \n    public static int knapsack01(int[] weights, int[] values, int capacity) {\n        int n = weights.length;\n        \n        // Create DP table\n        int[][] dp = new int[n + 1][capacity + 1];\n        \n        // Fill the DP table\n        for (int i = 1; i <= n; i++) {\n            for (int w = 1; w <= capacity; w++) {\n                if (weights[i - 1] > w) {\n                    dp[i][w] = dp[i - 1][w];\n                } else {\n                    int include = values[i - 1] + dp[i - 1][w - weights[i - 1]];\n                    int exclude = dp[i - 1][w];\n                    dp[i][w] = Math.max(include, exclude);\n                }\n            }\n        }\n        \n        return dp[n][capacity];\n    }\n    \n    public static class KnapsackResult {\n        public int maxValue;\n        public List<Integer> selectedItems;\n        \n        public KnapsackResult(int maxValue, List<Integer> selectedItems) {\n            this.maxValue = maxValue;\n            this.selectedItems = selectedItems;\n        }\n    }\n    \n    public static KnapsackResult knapsackWithItems(int[] weights, int[] values, int capacity) {\n        int n = weights.length;\n        int[][] dp = new int[n + 1][capacity + 1];\n        \n        // Fill DP table\n        for (int i = 1; i <= n; i++) {\n            for (int w = 1; w <= capacity; w++) {\n                if (weights[i - 1] > w) {\n                    dp[i][w] = dp[i - 1][w];\n                } else {\n                    int include = values[i - 1] + dp[i - 1][w - weights[i - 1]];\n                    int exclude = dp[i - 1][w];\n                    dp[i][w] = Math.max(include, exclude);\n                }\n            }\n        }\n        \n        // Backtrack to find selected items\n        List<Integer> selectedItems = new ArrayList<>();\n        int w = capacity;\n        \n        for (int i = n; i > 0; i--) {\n            if (dp[i][w] != dp[i - 1][w]) {\n                selectedItems.add(i - 1); // Store 0-based index\n                w -= weights[i - 1];\n            }\n        }\n        \n        Collections.reverse(selectedItems);\n        return new KnapsackResult(dp[n][capacity], selectedItems);\n    }\n    \n    public static int knapsackSpaceOptimized(int[] weights, int[] values, int capacity) {\n        int n = weights.length;\n        int[] dp = new int[capacity + 1];\n        \n        for (int i = 0; i < n; i++) {\n            // Traverse from right to left\n            for (int w = capacity; w >= weights[i]; w--) {\n                dp[w] = Math.max(dp[w], dp[w - weights[i]] + values[i]);\n            }\n        }\n        \n        return dp[capacity];\n    }\n    \n    public static int unboundedKnapsack(int[] weights, int[] values, int capacity) {\n        int n = weights.length;\n        int[] dp = new int[capacity + 1];\n        \n        for (int w = 1; w <= capacity; w++) {\n            for (int i = 0; i < n; i++) {\n                if (weights[i] <= w) {\n                    dp[w] = Math.max(dp[w], dp[w - weights[i]] + values[i]);\n                }\n            }\n        }\n        \n        return dp[capacity];\n    }\n    \n    public static class FractionalResult {\n        public double maxValue;\n        public List<ItemFraction> selectedItems;\n        \n        public FractionalResult(double maxValue, List<ItemFraction> selectedItems) {\n            this.maxValue = maxValue;\n            this.selectedItems = selectedItems;\n        }\n    }\n    \n    public static class ItemFraction {\n        public int itemIndex;\n        public double fraction;\n        \n        public ItemFraction(int itemIndex, double fraction) {\n            this.itemIndex = itemIndex;\n            this.fraction = fraction;\n        }\n    }\n    \n    public static class Item implements Comparable<Item> {\n        public double ratio;\n        public int weight;\n        public int value;\n        public int index;\n        \n        public Item(double ratio, int weight, int value, int index) {\n            this.ratio = ratio;\n            this.weight = weight;\n            this.value = value;\n            this.index = index;\n        }\n        \n        @Override\n        public int compareTo(Item other) {\n            return Double.compare(other.ratio, this.ratio); // Descending order\n        }\n    }\n    \n    public static FractionalResult fractionalKnapsack(int[] weights, int[] values, int capacity) {\n        int n = weights.length;\n        \n        // Create items with value-to-weight ratio\n        List<Item> items = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            items.add(new Item((double) values[i] / weights[i], weights[i], values[i], i));\n        }\n        \n        // Sort by ratio in descending order\n        Collections.sort(items);\n        \n        double totalValue = 0;\n        List<ItemFraction> selectedItems = new ArrayList<>();\n        int remainingCapacity = capacity;\n        \n        for (Item item : items) {\n            if (remainingCapacity >= item.weight) {\n                // Take the whole item\n                totalValue += item.value;\n                remainingCapacity -= item.weight;\n                selectedItems.add(new ItemFraction(item.index, 1.0));\n            } else if (remainingCapacity > 0) {\n                // Take fraction of the item\n                double fraction = (double) remainingCapacity / item.weight;\n                totalValue += item.value * fraction;\n                selectedItems.add(new ItemFraction(item.index, fraction));\n                remainingCapacity = 0;\n                break;\n            }\n        }\n        \n        return new FractionalResult(totalValue, selectedItems);\n    }\n    \n    // Memoized recursive approach\n    public static int knapsackRecursive(int[] weights, int[] values, int capacity) {\n        Map<String, Integer> memo = new HashMap<>();\n        return knapsackRecursiveHelper(weights, values, capacity, 0, memo);\n    }\n    \n    private static int knapsackRecursiveHelper(int[] weights, int[] values, int capacity, \n                                              int index, Map<String, Integer> memo) {\n        if (index >= weights.length || capacity <= 0) {\n            return 0;\n        }\n        \n        String key = index + \",\" + capacity;\n        if (memo.containsKey(key)) {\n            return memo.get(key);\n        }\n        \n        int result;\n        if (weights[index] > capacity) {\n            // Cannot include current item\n            result = knapsackRecursiveHelper(weights, values, capacity, index + 1, memo);\n        } else {\n            // Choose maximum of including or excluding current item\n            int include = values[index] + \n                         knapsackRecursiveHelper(weights, values, capacity - weights[index], index + 1, memo);\n            int exclude = knapsackRecursiveHelper(weights, values, capacity, index + 1, memo);\n            result = Math.max(include, exclude);\n        }\n        \n        memo.put(key, result);\n        return result;\n    }\n    \n    // Multiple constraints knapsack\n    public static int knapsackMultipleConstraints(int[] weights, int[] values, int capacity, \n                                                 int[] volumes, int volumeLimit) {\n        int n = weights.length;\n        \n        // 3D DP table\n        int[][][] dp = new int[n + 1][capacity + 1][volumeLimit + 1];\n        \n        for (int i = 1; i <= n; i++) {\n            for (int w = 0; w <= capacity; w++) {\n                for (int v = 0; v <= volumeLimit; v++) {\n                    // Don't include current item\n                    dp[i][w][v] = dp[i - 1][w][v];\n                    \n                    // Include current item if constraints allow\n                    if (weights[i - 1] <= w && volumes[i - 1] <= v) {\n                        int includeValue = values[i - 1] + \n                                         dp[i - 1][w - weights[i - 1]][v - volumes[i - 1]];\n                        dp[i][w][v] = Math.max(dp[i][w][v], includeValue);\n                    }\n                }\n            }\n        }\n        \n        return dp[n][capacity][volumeLimit];\n    }\n    \n    // Example usage\n    public static void main(String[] args) {\n        int[] weights = {10, 20, 30};\n        int[] values = {60, 100, 120};\n        int capacity = 50;\n        \n        int maxValue = knapsack01(weights, values, capacity);\n        System.out.println(\"0/1 Knapsack max value: \" + maxValue);\n        \n        KnapsackResult result = knapsackWithItems(weights, values, capacity);\n        System.out.println(\"Selected items: \" + result.selectedItems);\n        System.out.println(\"Max value with items: \" + result.maxValue);\n        \n        int maxValueOpt = knapsackSpaceOptimized(weights, values, capacity);\n        System.out.println(\"Space-optimized max value: \" + maxValueOpt);\n        \n        int unboundedValue = unboundedKnapsack(weights, values, capacity);\n        System.out.println(\"Unbounded knapsack max value: \" + unboundedValue);\n        \n        FractionalResult fracResult = fractionalKnapsack(weights, values, capacity);\n        System.out.printf(\"Fractional knapsack max value: %.2f%n\", fracResult.maxValue);\n        \n        int recursiveValue = knapsackRecursive(weights, values, capacity);\n        System.out.println(\"Recursive knapsack max value: \" + recursiveValue);\n        \n        // Test multiple constraints\n        int[] volumes = {5, 10, 15};\n        int volumeLimit = 25;\n        int multiValue = knapsackMultipleConstraints(weights, values, capacity, volumes, volumeLimit);\n        System.out.println(\"Multi-constraint knapsack max value: \" + multiValue);\n    }\n}",
        "csharp": "// C# Knapsack Implementation\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic class KnapsackProblem\n{\n    public static int Knapsack01(int[] weights, int[] values, int capacity)\n    {\n        int n = weights.Length;\n        \n        // Create DP table\n        int[,] dp = new int[n + 1, capacity + 1];\n        \n        // Fill the DP table\n        for (int i = 1; i <= n; i++)\n        {\n            for (int w = 1; w <= capacity; w++)\n            {\n                if (weights[i - 1] > w)\n                {\n                    dp[i, w] = dp[i - 1, w];\n                }\n                else\n                {\n                    int include = values[i - 1] + dp[i - 1, w - weights[i - 1]];\n                    int exclude = dp[i - 1, w];\n                    dp[i, w] = Math.Max(include, exclude);\n                }\n            }\n        }\n        \n        return dp[n, capacity];\n    }\n    \n    public class KnapsackResult\n    {\n        public int MaxValue { get; set; }\n        public List<int> SelectedItems { get; set; }\n        \n        public KnapsackResult(int maxValue, List<int> selectedItems)\n        {\n            MaxValue = maxValue;\n            SelectedItems = selectedItems;\n        }\n    }\n    \n    public static KnapsackResult KnapsackWithItems(int[] weights, int[] values, int capacity)\n    {\n        int n = weights.Length;\n        int[,] dp = new int[n + 1, capacity + 1];\n        \n        // Fill DP table\n        for (int i = 1; i <= n; i++)\n        {\n            for (int w = 1; w <= capacity; w++)\n            {\n                if (weights[i - 1] > w)\n                {\n                    dp[i, w] = dp[i - 1, w];\n                }\n                else\n                {\n                    int include = values[i - 1] + dp[i - 1, w - weights[i - 1]];\n                    int exclude = dp[i - 1, w];\n                    dp[i, w] = Math.Max(include, exclude);\n                }\n            }\n        }\n        \n        // Backtrack to find selected items\n        var selectedItems = new List<int>();\n        int weight = capacity;\n        \n        for (int i = n; i > 0; i--)\n        {\n            if (dp[i, weight] != dp[i - 1, weight])\n            {\n                selectedItems.Add(i - 1); // Store 0-based index\n                weight -= weights[i - 1];\n            }\n        }\n        \n        selectedItems.Reverse();\n        return new KnapsackResult(dp[n, capacity], selectedItems);\n    }\n    \n    public static int KnapsackSpaceOptimized(int[] weights, int[] values, int capacity)\n    {\n        int n = weights.Length;\n        int[] dp = new int[capacity + 1];\n        \n        for (int i = 0; i < n; i++)\n        {\n            // Traverse from right to left\n            for (int w = capacity; w >= weights[i]; w--)\n            {\n                dp[w] = Math.Max(dp[w], dp[w - weights[i]] + values[i]);\n            }\n        }\n        \n        return dp[capacity];\n    }\n    \n    public static int UnboundedKnapsack(int[] weights, int[] values, int capacity)\n    {\n        int n = weights.Length;\n        int[] dp = new int[capacity + 1];\n        \n        for (int w = 1; w <= capacity; w++)\n        {\n            for (int i = 0; i < n; i++)\n            {\n                if (weights[i] <= w)\n                {\n                    dp[w] = Math.Max(dp[w], dp[w - weights[i]] + values[i]);\n                }\n            }\n        }\n        \n        return dp[capacity];\n    }\n    \n    public class FractionalResult\n    {\n        public double MaxValue { get; set; }\n        public List<(int itemIndex, double fraction)> SelectedItems { get; set; }\n        \n        public FractionalResult(double maxValue, List<(int, double)> selectedItems)\n        {\n            MaxValue = maxValue;\n            SelectedItems = selectedItems;\n        }\n    }\n    \n    public static FractionalResult FractionalKnapsack(int[] weights, int[] values, int capacity)\n    {\n        int n = weights.Length;\n        \n        // Create items with value-to-weight ratio\n        var items = Enumerable.Range(0, n)\n            .Select(i => new { Ratio = (double)values[i] / weights[i], Weight = weights[i], Value = values[i], Index = i })\n            .OrderByDescending(item => item.Ratio)\n            .ToList();\n        \n        double totalValue = 0;\n        var selectedItems = new List<(int, double)>();\n        int remainingCapacity = capacity;\n        \n        foreach (var item in items)\n        {\n            if (remainingCapacity >= item.Weight)\n            {\n                // Take the whole item\n                totalValue += item.Value;\n                remainingCapacity -= item.Weight;\n                selectedItems.Add((item.Index, 1.0));\n            }\n            else if (remainingCapacity > 0)\n            {\n                // Take fraction of the item\n                double fraction = (double)remainingCapacity / item.Weight;\n                totalValue += item.Value * fraction;\n                selectedItems.Add((item.Index, fraction));\n                remainingCapacity = 0;\n                break;\n            }\n        }\n        \n        return new FractionalResult(totalValue, selectedItems);\n    }\n    \n    // Memoized recursive approach\n    public static int KnapsackRecursive(int[] weights, int[] values, int capacity)\n    {\n        var memo = new Dictionary<(int, int), int>();\n        return KnapsackRecursiveHelper(weights, values, capacity, 0, memo);\n    }\n    \n    private static int KnapsackRecursiveHelper(int[] weights, int[] values, int capacity, \n                                              int index, Dictionary<(int, int), int> memo)\n    {\n        if (index >= weights.Length || capacity <= 0)\n        {\n            return 0;\n        }\n        \n        var key = (index, capacity);\n        if (memo.ContainsKey(key))\n        {\n            return memo[key];\n        }\n        \n        int result;\n        if (weights[index] > capacity)\n        {\n            // Cannot include current item\n            result = KnapsackRecursiveHelper(weights, values, capacity, index + 1, memo);\n        }\n        else\n        {\n            // Choose maximum of including or excluding current item\n            int include = values[index] + \n                         KnapsackRecursiveHelper(weights, values, capacity - weights[index], index + 1, memo);\n            int exclude = KnapsackRecursiveHelper(weights, values, capacity, index + 1, memo);\n            result = Math.Max(include, exclude);\n        }\n        \n        memo[key] = result;\n        return result;\n    }\n    \n    // Multiple constraints knapsack\n    public static int KnapsackMultipleConstraints(int[] weights, int[] values, int capacity, \n                                                 int[] volumes, int volumeLimit)\n    {\n        int n = weights.Length;\n        \n        // 3D DP table\n        int[,,] dp = new int[n + 1, capacity + 1, volumeLimit + 1];\n        \n        for (int i = 1; i <= n; i++)\n        {\n            for (int w = 0; w <= capacity; w++)\n            {\n                for (int v = 0; v <= volumeLimit; v++)\n                {\n                    // Don't include current item\n                    dp[i, w, v] = dp[i - 1, w, v];\n                    \n                    // Include current item if constraints allow\n                    if (weights[i - 1] <= w && volumes[i - 1] <= v)\n                    {\n                        int includeValue = values[i - 1] + \n                                         dp[i - 1, w - weights[i - 1], v - volumes[i - 1]];\n                        dp[i, w, v] = Math.Max(dp[i, w, v], includeValue);\n                    }\n                }\n            }\n        }\n        \n        return dp[n, capacity, volumeLimit];\n    }\n    \n    // Calculate efficiency ratio\n    public static double CalculateEfficiency(int[] weights, int[] values, List<int> selectedItems)\n    {\n        int totalWeight = selectedItems.Sum(i => weights[i]);\n        int totalValue = selectedItems.Sum(i => values[i]);\n        \n        return totalWeight > 0 ? (double)totalValue / totalWeight : 0;\n    }\n    \n    // Example usage\n    static void Main(string[] args)\n    {\n        int[] weights = {10, 20, 30};\n        int[] values = {60, 100, 120};\n        int capacity = 50;\n        \n        int maxValue = Knapsack01(weights, values, capacity);\n        Console.WriteLine($\"0/1 Knapsack max value: {maxValue}\");\n        \n        var result = KnapsackWithItems(weights, values, capacity);\n        Console.WriteLine($\"Selected items: [{string.Join(\", \", result.SelectedItems)}]\");\n        Console.WriteLine($\"Max value with items: {result.MaxValue}\");\n        \n        int maxValueOpt = KnapsackSpaceOptimized(weights, values, capacity);\n        Console.WriteLine($\"Space-optimized max value: {maxValueOpt}\");\n        \n        int unboundedValue = UnboundedKnapsack(weights, values, capacity);\n        Console.WriteLine($\"Unbounded knapsack max value: {unboundedValue}\");\n        \n        var fracResult = FractionalKnapsack(weights, values, capacity);\n        Console.WriteLine($\"Fractional knapsack max value: {fracResult.MaxValue:F2}\");\n        \n        int recursiveValue = KnapsackRecursive(weights, values, capacity);\n        Console.WriteLine($\"Recursive knapsack max value: {recursiveValue}\");\n        \n        // Calculate efficiency\n        double efficiency = CalculateEfficiency(weights, values, result.SelectedItems);\n        Console.WriteLine($\"Selection efficiency: {efficiency:F2}\");\n        \n        // Test multiple constraints\n        int[] volumes = {5, 10, 15};\n        int volumeLimit = 25;\n        int multiValue = KnapsackMultipleConstraints(weights, values, capacity, volumes, volumeLimit);\n        Console.WriteLine($\"Multi-constraint knapsack max value: {multiValue}\");\n    }\n}"
      }
    },
     {
      "id": 18,
      "name": "Sliding Window Technique",
      "category": "Sliding Window",
      "description": "A technique that maintains a window of elements and slides it across the data structure to solve problems efficiently",
      "time_complexity": {
        "best": "O(n)",
        "average": "O(n)",
        "worst": "O(n)"
      },
      "space_complexity": "O(1)",
      "prerequisites": ["Two pointers technique", "Array manipulation"],
      "use_cases": ["Maximum/minimum subarray problems", "String pattern matching", "Longest substring problems", "Array sum problems"],
      "implementations": {
        "python": "def max_sum_subarray_k(arr, k):\n    \"\"\"\n    Find maximum sum of subarray of size k using sliding window\n    \"\"\"\n    if len(arr) < k:\n        return None\n    \n    # Calculate sum of first window\n    window_sum = sum(arr[:k])\n    max_sum = window_sum\n    \n    # Slide the window\n    for i in range(k, len(arr)):\n        window_sum = window_sum - arr[i - k] + arr[i]\n        max_sum = max(max_sum, window_sum)\n    \n    return max_sum\n\ndef longest_substring_without_repeating(s):\n    \"\"\"\n    Find length of longest substring without repeating characters\n    LeetCode Problem 3\n    \"\"\"\n    char_set = set()\n    left = 0\n    max_length = 0\n    \n    for right in range(len(s)):\n        # Shrink window until no duplicates\n        while s[right] in char_set:\n            char_set.remove(s[left])\n            left += 1\n        \n        char_set.add(s[right])\n        max_length = max(max_length, right - left + 1)\n    \n    return max_length\n\ndef min_window_substring(s, t):\n    \"\"\"\n    Find minimum window substring containing all characters of t\n    LeetCode Problem 76\n    \"\"\"\n    if not s or not t:\n        return \"\"\n    \n    # Count characters in t\n    dict_t = {}\n    for char in t:\n        dict_t[char] = dict_t.get(char, 0) + 1\n    \n    required = len(dict_t)\n    left, right = 0, 0\n    formed = 0\n    \n    window_counts = {}\n    ans = float('inf'), None, None\n    \n    while right < len(s):\n        # Add character from right to window\n        character = s[right]\n        window_counts[character] = window_counts.get(character, 0) + 1\n        \n        # Check if current character's frequency matches desired frequency\n        if character in dict_t and window_counts[character] == dict_t[character]:\n            formed += 1\n        \n        # Try to contract window\n        while left <= right and formed == required:\n            character = s[left]\n            \n            # Save the smallest window\n            if right - left + 1 < ans[0]:\n                ans = (right - left + 1, left, right)\n            \n            # Remove character from left\n            window_counts[character] -= 1\n            if character in dict_t and window_counts[character] < dict_t[character]:\n                formed -= 1\n            \n            left += 1\n        \n        right += 1\n    \n    return \"\" if ans[0] == float('inf') else s[ans[1]:ans[2] + 1]\n\ndef max_consecutive_ones_k_flips(nums, k):\n    \"\"\"\n    Find maximum consecutive 1s after flipping at most k zeros\n    LeetCode Problem 1004\n    \"\"\"\n    left = 0\n    zero_count = 0\n    max_length = 0\n    \n    for right in range(len(nums)):\n        if nums[right] == 0:\n            zero_count += 1\n        \n        # Shrink window if we have more than k zeros\n        while zero_count > k:\n            if nums[left] == 0:\n                zero_count -= 1\n            left += 1\n        \n        max_length = max(max_length, right - left + 1)\n    \n    return max_length\n\ndef find_all_anagrams(s, p):\n    \"\"\"\n    Find all start indices of anagrams of p in s\n    LeetCode Problem 438\n    \"\"\"\n    if len(p) > len(s):\n        return []\n    \n    # Count characters in p\n    p_count = {}\n    for char in p:\n        p_count[char] = p_count.get(char, 0) + 1\n    \n    window_count = {}\n    result = []\n    window_size = len(p)\n    \n    for i in range(len(s)):\n        # Add character to window\n        char = s[i]\n        window_count[char] = window_count.get(char, 0) + 1\n        \n        # Remove character from left if window is too large\n        if i >= window_size:\n            left_char = s[i - window_size]\n            window_count[left_char] -= 1\n            if window_count[left_char] == 0:\n                del window_count[left_char]\n        \n        # Check if current window is an anagram\n        if window_count == p_count:\n            result.append(i - window_size + 1)\n    \n    return result\n\ndef longest_repeating_character_replacement(s, k):\n    \"\"\"\n    Find length of longest substring with same characters after k replacements\n    LeetCode Problem 424\n    \"\"\"\n    char_count = {}\n    left = 0\n    max_count = 0\n    max_length = 0\n    \n    for right in range(len(s)):\n        char_count[s[right]] = char_count.get(s[right], 0) + 1\n        max_count = max(max_count, char_count[s[right]])\n        \n        # If window size - max_count > k, shrink window\n        if right - left + 1 - max_count > k:\n            char_count[s[left]] -= 1\n            left += 1\n        \n        max_length = max(max_length, right - left + 1)\n    \n    return max_length\n\n# Example usage\nif __name__ == \"__main__\":\n    # Test maximum sum subarray\n    arr = [2, 1, 5, 1, 3, 2]\n    k = 3\n    print(f\"Max sum of subarray size {k}: {max_sum_subarray_k(arr, k)}\")  # 9\n    \n    # Test longest substring without repeating\n    s = \"abcabcbb\"\n    print(f\"Longest substring without repeating: {longest_substring_without_repeating(s)}\")  # 3\n    \n    # Test minimum window substring\n    s, t = \"ADOBECODEBANC\", \"ABC\"\n    print(f\"Minimum window substring: '{min_window_substring(s, t)}'\")  # \"BANC\"\n    \n    # Test find all anagrams\n    s, p = \"abab\", \"ab\"\n    print(f\"Anagram indices: {find_all_anagrams(s, p)}\")  # [0, 2]",
        "java": "// Java Sliding Window Implementation\nimport java.util.*;\n\npublic class SlidingWindow {\n    \n    // Maximum sum of subarray of size k\n    public static int maxSumSubarrayK(int[] arr, int k) {\n        if (arr.length < k) {\n            return -1;\n        }\n        \n        // Calculate sum of first window\n        int windowSum = 0;\n        for (int i = 0; i < k; i++) {\n            windowSum += arr[i];\n        }\n        \n        int maxSum = windowSum;\n        \n        // Slide the window\n        for (int i = k; i < arr.length; i++) {\n            windowSum = windowSum - arr[i - k] + arr[i];\n            maxSum = Math.max(maxSum, windowSum);\n        }\n        \n        return maxSum;\n    }\n    \n    // Longest substring without repeating characters (LeetCode 3)\n    public static int lengthOfLongestSubstring(String s) {\n        Set<Character> charSet = new HashSet<>();\n        int left = 0;\n        int maxLength = 0;\n        \n        for (int right = 0; right < s.length(); right++) {\n            // Shrink window until no duplicates\n            while (charSet.contains(s.charAt(right))) {\n                charSet.remove(s.charAt(left));\n                left++;\n            }\n            \n            charSet.add(s.charAt(right));\n            maxLength = Math.max(maxLength, right - left + 1);\n        }\n        \n        return maxLength;\n    }\n    \n    // Minimum window substring (LeetCode 76)\n    public static String minWindow(String s, String t) {\n        if (s.length() == 0 || t.length() == 0) {\n            return \"\";\n        }\n        \n        // Count characters in t\n        Map<Character, Integer> dictT = new HashMap<>();\n        for (char c : t.toCharArray()) {\n            dictT.put(c, dictT.getOrDefault(c, 0) + 1);\n        }\n        \n        int required = dictT.size();\n        int left = 0, right = 0;\n        int formed = 0;\n        \n        Map<Character, Integer> windowCounts = new HashMap<>();\n        int[] ans = {Integer.MAX_VALUE, 0, 0}; // length, left, right\n        \n        while (right < s.length()) {\n            // Add character from right to window\n            char character = s.charAt(right);\n            windowCounts.put(character, windowCounts.getOrDefault(character, 0) + 1);\n            \n            // Check if current character's frequency matches desired frequency\n            if (dictT.containsKey(character) && \n                windowCounts.get(character).intValue() == dictT.get(character).intValue()) {\n                formed++;\n            }\n            \n            // Try to contract window\n            while (left <= right && formed == required) {\n                character = s.charAt(left);\n                \n                // Save the smallest window\n                if (right - left + 1 < ans[0]) {\n                    ans[0] = right - left + 1;\n                    ans[1] = left;\n                    ans[2] = right;\n                }\n                \n                // Remove character from left\n                windowCounts.put(character, windowCounts.get(character) - 1);\n                if (dictT.containsKey(character) && \n                    windowCounts.get(character) < dictT.get(character)) {\n                    formed--;\n                }\n                \n                left++;\n            }\n            \n            right++;\n        }\n        \n        return ans[0] == Integer.MAX_VALUE ? \"\" : s.substring(ans[1], ans[2] + 1);\n    }\n    \n    // Maximum consecutive ones with k flips (LeetCode 1004)\n    public static int longestOnes(int[] nums, int k) {\n        int left = 0;\n        int zeroCount = 0;\n        int maxLength = 0;\n        \n        for (int right = 0; right < nums.length; right++) {\n            if (nums[right] == 0) {\n                zeroCount++;\n            }\n            \n            // Shrink window if we have more than k zeros\n            while (zeroCount > k) {\n                if (nums[left] == 0) {\n                    zeroCount--;\n                }\n                left++;\n            }\n            \n            maxLength = Math.max(maxLength, right - left + 1);\n        }\n        \n        return maxLength;\n    }\n    \n    // Find all anagrams in string (LeetCode 438)\n    public static List<Integer> findAnagrams(String s, String p) {\n        List<Integer> result = new ArrayList<>();\n        if (p.length() > s.length()) {\n            return result;\n        }\n        \n        // Count characters in p\n        Map<Character, Integer> pCount = new HashMap<>();\n        for (char c : p.toCharArray()) {\n            pCount.put(c, pCount.getOrDefault(c, 0) + 1);\n        }\n        \n        Map<Character, Integer> windowCount = new HashMap<>();\n        int windowSize = p.length();\n        \n        for (int i = 0; i < s.length(); i++) {\n            // Add character to window\n            char c = s.charAt(i);\n            windowCount.put(c, windowCount.getOrDefault(c, 0) + 1);\n            \n            // Remove character from left if window is too large\n            if (i >= windowSize) {\n                char leftChar = s.charAt(i - windowSize);\n                windowCount.put(leftChar, windowCount.get(leftChar) - 1);\n                if (windowCount.get(leftChar) == 0) {\n                    windowCount.remove(leftChar);\n                }\n            }\n            \n            // Check if current window is an anagram\n            if (windowCount.equals(pCount)) {\n                result.add(i - windowSize + 1);\n            }\n        }\n        \n        return result;\n    }\n    \n    // Longest repeating character replacement (LeetCode 424)\n    public static int characterReplacement(String s, int k) {\n        Map<Character, Integer> charCount = new HashMap<>();\n        int left = 0;\n        int maxCount = 0;\n        int maxLength = 0;\n        \n        for (int right = 0; right < s.length(); right++) {\n            char c = s.charAt(right);\n            charCount.put(c, charCount.getOrDefault(c, 0) + 1);\n            maxCount = Math.max(maxCount, charCount.get(c));\n            \n            // If window size - max_count > k, shrink window\n            if (right - left + 1 - maxCount > k) {\n                char leftChar = s.charAt(left);\n                charCount.put(leftChar, charCount.get(leftChar) - 1);\n                left++;\n            }\n            \n            maxLength = Math.max(maxLength, right - left + 1);\n        }\n        \n        return maxLength;\n    }\n    \n    // Example usage\n    public static void main(String[] args) {\n        // Test maximum sum subarray\n        int[] arr = {2, 1, 5, 1, 3, 2};\n        int k = 3;\n        System.out.println(\"Max sum of subarray size \" + k + \": \" + maxSumSubarrayK(arr, k));\n        \n        // Test longest substring without repeating\n        String s = \"abcabcbb\";\n        System.out.println(\"Longest substring without repeating: \" + lengthOfLongestSubstring(s));\n        \n        // Test minimum window substring\n        String s1 = \"ADOBECODEBANC\", t = \"ABC\";\n        System.out.println(\"Minimum window substring: '\" + minWindow(s1, t) + \"'\");\n        \n        // Test find all anagrams\n        String s2 = \"abab\", p = \"ab\";\n        System.out.println(\"Anagram indices: \" + findAnagrams(s2, p));\n    }\n}",
        "csharp": "// C# Sliding Window Implementation\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic class SlidingWindow\n{\n    // Maximum sum of subarray of size k\n    public static int MaxSumSubarrayK(int[] arr, int k)\n    {\n        if (arr.Length < k)\n        {\n            return -1;\n        }\n        \n        // Calculate sum of first window\n        int windowSum = arr.Take(k).Sum();\n        int maxSum = windowSum;\n        \n        // Slide the window\n        for (int i = k; i < arr.Length; i++)\n        {\n            windowSum = windowSum - arr[i - k] + arr[i];\n            maxSum = Math.Max(maxSum, windowSum);\n        }\n        \n        return maxSum;\n    }\n    \n    // Longest substring without repeating characters (LeetCode 3)\n    public static int LengthOfLongestSubstring(string s)\n    {\n        var charSet = new HashSet<char>();\n        int left = 0;\n        int maxLength = 0;\n        \n        for (int right = 0; right < s.Length; right++)\n        {\n            // Shrink window until no duplicates\n            while (charSet.Contains(s[right]))\n            {\n                charSet.Remove(s[left]);\n                left++;\n            }\n            \n            charSet.Add(s[right]);\n            maxLength = Math.Max(maxLength, right - left + 1);\n        }\n        \n        return maxLength;\n    }\n    \n    // Minimum window substring (LeetCode 76)\n    public static string MinWindow(string s, string t)\n    {\n        if (s.Length == 0 || t.Length == 0)\n        {\n            return \"\";\n        }\n        \n        // Count characters in t\n        var dictT = new Dictionary<char, int>();\n        foreach (char c in t)\n        {\n            dictT[c] = dictT.GetValueOrDefault(c, 0) + 1;\n        }\n        \n        int required = dictT.Count;\n        int left = 0, right = 0;\n        int formed = 0;\n        \n        var windowCounts = new Dictionary<char, int>();\n        var ans = new int[] { int.MaxValue, 0, 0 }; // length, left, right\n        \n        while (right < s.Length)\n        {\n            // Add character from right to window\n            char character = s[right];\n            windowCounts[character] = windowCounts.GetValueOrDefault(character, 0) + 1;\n            \n            // Check if current character's frequency matches desired frequency\n            if (dictT.ContainsKey(character) && \n                windowCounts[character] == dictT[character])\n            {\n                formed++;\n            }\n            \n            // Try to contract window\n            while (left <= right && formed == required)\n            {\n                character = s[left];\n                \n                // Save the smallest window\n                if (right - left + 1 < ans[0])\n                {\n                    ans[0] = right - left + 1;\n                    ans[1] = left;\n                    ans[2] = right;\n                }\n                \n                // Remove character from left\n                windowCounts[character]--;\n                if (dictT.ContainsKey(character) && \n                    windowCounts[character] < dictT[character])\n                {\n                    formed--;\n                }\n                \n                left++;\n            }\n            \n            right++;\n        }\n        \n        return ans[0] == int.MaxValue ? \"\" : s.Substring(ans[1], ans[0]);\n    }\n    \n    // Maximum consecutive ones with k flips (LeetCode 1004)\n    public static int LongestOnes(int[] nums, int k)\n    {\n        int left = 0;\n        int zeroCount = 0;\n        int maxLength = 0;\n        \n        for (int right = 0; right < nums.Length; right++)\n        {\n            if (nums[right] == 0)\n            {\n                zeroCount++;\n            }\n            \n            // Shrink window if we have more than k zeros\n            while (zeroCount > k)\n            {\n                if (nums[left] == 0)\n                {\n                    zeroCount--;\n                }\n                left++;\n            }\n            \n            maxLength = Math.Max(maxLength, right - left + 1);\n        }\n        \n        return maxLength;\n    }\n    \n    // Find all anagrams in string (LeetCode 438)\n    public static List<int> FindAnagrams(string s, string p)\n    {\n        var result = new List<int>();\n        if (p.Length > s.Length)\n        {\n            return result;\n        }\n        \n        // Count characters in p\n        var pCount = new Dictionary<char, int>();\n        foreach (char c in p)\n        {\n            pCount[c] = pCount.GetValueOrDefault(c, 0) + 1;\n        }\n        \n        var windowCount = new Dictionary<char, int>();\n        int windowSize = p.Length;\n        \n        for (int i = 0; i < s.Length; i++)\n        {\n            // Add character to window\n            char c = s[i];\n            windowCount[c] = windowCount.GetValueOrDefault(c, 0) + 1;\n            \n            // Remove character from left if window is too large\n            if (i >= windowSize)\n            {\n                char leftChar = s[i - windowSize];\n                windowCount[leftChar]--;\n                if (windowCount[leftChar] == 0)\n                {\n                    windowCount.Remove(leftChar);\n                }\n            }\n            \n            // Check if current window is an anagram\n            if (windowCount.Count == pCount.Count && \n                windowCount.All(kvp => pCount.ContainsKey(kvp.Key) && pCount[kvp.Key] == kvp.Value))\n            {\n                result.Add(i - windowSize + 1);\n            }\n        }\n        \n        return result;\n    }\n    \n    // Longest repeating character replacement (LeetCode 424)\n    public static int CharacterReplacement(string s, int k)\n    {\n        var charCount = new Dictionary<char, int>();\n        int left = 0;\n        int maxCount = 0;\n        int maxLength = 0;\n        \n        for (int right = 0; right < s.Length; right++)\n        {\n            char c = s[right];\n            charCount[c] = charCount.GetValueOrDefault(c, 0) + 1;\n            maxCount = Math.Max(maxCount, charCount[c]);\n            \n            // If window size - max_count > k, shrink window\n            if (right - left + 1 - maxCount > k)\n            {\n                char leftChar = s[left];\n                charCount[leftChar]--;\n                left++;\n            }\n            \n            maxLength = Math.Max(maxLength, right - left + 1);\n        }\n        \n        return maxLength;\n    }\n    \n    // Example usage\n    static void Main(string[] args)\n    {\n        // Test maximum sum subarray\n        int[] arr = {2, 1, 5, 1, 3, 2};\n        int k = 3;\n        Console.WriteLine($\"Max sum of subarray size {k}: {MaxSumSubarrayK(arr, k)}\");\n        \n        // Test longest substring without repeating\n        string s = \"abcabcbb\";\n        Console.WriteLine($\"Longest substring without repeating: {LengthOfLongestSubstring(s)}\");\n        \n        // Test minimum window substring\n        string s1 = \"ADOBECODEBANC\", t = \"ABC\";\n        Console.WriteLine($\"Minimum window substring: '{MinWindow(s1, t)}'\");\n        \n        // Test find all anagrams\n        string s2 = \"abab\", p = \"ab\";\n        Console.WriteLine($\"Anagram indices: [{string.Join(\", \", FindAnagrams(s2, p))}]\");\n    }\n}"
      }
    },
    {
      "id": 19,
      "name": "Backtracking",
      "category": "Backtracking",
      "description": "An algorithmic approach that considers searching every possible combination to solve computational problems by incrementally building solutions and abandoning candidates that cannot lead to a valid solution",
      "time_complexity": {
        "best": "O(b^d)",
        "average": "O(b^d)",
        "worst": "O(b^d)"
      },
      "space_complexity": "O(d)",
      "prerequisites": ["Recursion", "Tree traversal", "Constraint satisfaction"],
      "use_cases": ["N-Queens problem", "Sudoku solver", "Permutations and combinations", "Maze solving"],
      "implementations": {
        "python": "def generate_permutations(nums):\n    \"\"\"\n    Generate all permutations of a list\n    LeetCode Problem 46\n    \"\"\"\n    result = []\n    \n    def backtrack(current_permutation):\n        # Base case: if permutation is complete\n        if len(current_permutation) == len(nums):\n            result.append(current_permutation[:])\n            return\n        \n        # Try each number not yet used\n        for num in nums:\n            if num not in current_permutation:\n                current_permutation.append(num)\n                backtrack(current_permutation)\n                current_permutation.pop()  # Backtrack\n    \n    backtrack([])\n    return result\n\ndef generate_combinations(n, k):\n    \"\"\"\n    Generate all combinations of k numbers from 1 to n\n    LeetCode Problem 77\n    \"\"\"\n    result = []\n    \n    def backtrack(start, current_combination):\n        # Base case: if combination is complete\n        if len(current_combination) == k:\n            result.append(current_combination[:])\n            return\n        \n        # Try numbers from start to n\n        for i in range(start, n + 1):\n            current_combination.append(i)\n            backtrack(i + 1, current_combination)\n            current_combination.pop()  # Backtrack\n    \n    backtrack(1, [])\n    return result\n\ndef solve_n_queens(n):\n    \"\"\"\n    Solve N-Queens problem\n    LeetCode Problem 51\n    \"\"\"\n    result = []\n    board = [['.' for _ in range(n)] for _ in range(n)]\n    \n    def is_safe(row, col):\n        # Check column\n        for i in range(row):\n            if board[i][col] == 'Q':\n                return False\n        \n        # Check diagonal (top-left to bottom-right)\n        i, j = row - 1, col - 1\n        while i >= 0 and j >= 0:\n            if board[i][j] == 'Q':\n                return False\n            i -= 1\n            j -= 1\n        \n        # Check diagonal (top-right to bottom-left)\n        i, j = row - 1, col + 1\n        while i >= 0 and j < n:\n            if board[i][j] == 'Q':\n                return False\n            i -= 1\n            j += 1\n        \n        return True\n    \n    def backtrack(row):\n        # Base case: all queens placed\n        if row == n:\n            result.append([''.join(row) for row in board])\n            return\n        \n        # Try placing queen in each column of current row\n        for col in range(n):\n            if is_safe(row, col):\n                board[row][col] = 'Q'\n                backtrack(row + 1)\n                board[row][col] = '.'  # Backtrack\n    \n    backtrack(0)\n    return result\n\ndef solve_sudoku(board):\n    \"\"\"\n    Solve Sudoku puzzle\n    LeetCode Problem 37\n    \"\"\"\n    def is_valid(board, row, col, num):\n        # Check row\n        for j in range(9):\n            if board[row][j] == num:\n                return False\n        \n        # Check column\n        for i in range(9):\n            if board[i][col] == num:\n                return False\n        \n        # Check 3x3 box\n        start_row, start_col = 3 * (row // 3), 3 * (col // 3)\n        for i in range(start_row, start_row + 3):\n            for j in range(start_col, start_col + 3):\n                if board[i][j] == num:\n                    return False\n        \n        return True\n    \n    def backtrack():\n        for i in range(9):\n            for j in range(9):\n                if board[i][j] == '.':\n                    for num in '123456789':\n                        if is_valid(board, i, j, num):\n                            board[i][j] = num\n                            if backtrack():\n                                return True\n                            board[i][j] = '.'  # Backtrack\n                    return False\n        return True\n    \n    backtrack()\n    return board\n\ndef generate_parentheses(n):\n    \"\"\"\n    Generate all valid parentheses combinations\n    LeetCode Problem 22\n    \"\"\"\n    result = []\n    \n    def backtrack(current, open_count, close_count):\n        # Base case: string is complete\n        if len(current) == 2 * n:\n            result.append(current)\n            return\n        \n        # Add opening parenthesis if we haven't used all\n        if open_count < n:\n            backtrack(current + '(', open_count + 1, close_count)\n        \n        # Add closing parenthesis if it won't make string invalid\n        if close_count < open_count:\n            backtrack(current + ')', open_count, close_count + 1)\n    \n    backtrack('', 0, 0)\n    return result\n\ndef word_search(board, word):\n    \"\"\"\n    Search for word in 2D board\n    LeetCode Problem 79\n    \"\"\"\n    if not board or not board[0]:\n        return False\n    \n    rows, cols = len(board), len(board[0])\n    \n    def backtrack(row, col, index):\n        # Base case: found the word\n        if index == len(word):\n            return True\n        \n        # Check bounds and character match\n        if (row < 0 or row >= rows or col < 0 or col >= cols or \n            board[row][col] != word[index]):\n            return False\n        \n        # Mark cell as visited\n        temp = board[row][col]\n        board[row][col] = '#'\n        \n        # Explore all 4 directions\n        found = (backtrack(row + 1, col, index + 1) or\n                backtrack(row - 1, col, index + 1) or\n                backtrack(row, col + 1, index + 1) or\n                backtrack(row, col - 1, index + 1))\n        \n        # Restore cell value (backtrack)\n        board[row][col] = temp\n        \n        return found\n    \n    # Try starting from each cell\n    for i in range(rows):\n        for j in range(cols):\n            if backtrack(i, j, 0):\n                return True\n    \n    return False\n\ndef subset_sum(nums, target):\n    \"\"\"\n    Find if there's a subset that sums to target\n    \"\"\"\n    def backtrack(index, current_sum):\n        # Base case: found target sum\n        if current_sum == target:\n            return True\n        \n        # Base case: exceeded target or no more numbers\n        if current_sum > target or index >= len(nums):\n            return False\n        \n        # Include current number or exclude it\n        return (backtrack(index + 1, current_sum + nums[index]) or\n                backtrack(index + 1, current_sum))\n    \n    return backtrack(0, 0)\n\n# Example usage\nif __name__ == \"__main__\":\n    # Test permutations\n    nums = [1, 2, 3]\n    print(f\"Permutations of {nums}: {generate_permutations(nums)}\")\n    \n    # Test combinations\n    print(f\"Combinations C(4,2): {generate_combinations(4, 2)}\")\n    \n    # Test N-Queens\n    n_queens_solutions = solve_n_queens(4)\n    print(f\"4-Queens solutions: {len(n_queens_solutions)} found\")\n    \n    # Test parentheses generation\n    print(f\"Valid parentheses (n=3): {generate_parentheses(3)}\")\n    \n    # Test subset sum\n    nums = [3, 34, 4, 12, 5, 2]\n    target = 9\n    print(f\"Subset sum exists for target {target}: {subset_sum(nums, target)}\")",
        "java": "// Java Backtracking Implementation\nimport java.util.*;\n\npublic class Backtracking {\n    \n    // Generate all permutations (LeetCode 46)\n    public static List<List<Integer>> permute(int[] nums) {\n        List<List<Integer>> result = new ArrayList<>();\n        backtrackPermutations(nums, new ArrayList<>(), result);\n        return result;\n    }\n    \n    private static void backtrackPermutations(int[] nums, List<Integer> current, \n                                            List<List<Integer>> result) {\n        // Base case: permutation is complete\n        if (current.size() == nums.length) {\n            result.add(new ArrayList<>(current));\n            return;\n        }\n        \n        // Try each number not yet used\n        for (int num : nums) {\n            if (!current.contains(num)) {\n                current.add(num);\n                backtrackPermutations(nums, current, result);\n                current.remove(current.size() - 1); // Backtrack\n            }\n        }\n    }\n    \n    // Generate combinations (LeetCode 77)\n    public static List<List<Integer>> combine(int n, int k) {\n        List<List<Integer>> result = new ArrayList<>();\n        backtrackCombinations(1, n, k, new ArrayList<>(), result);\n        return result;\n    }\n    \n    private static void backtrackCombinations(int start, int n, int k, \n                                            List<Integer> current, List<List<Integer>> result) {\n        // Base case: combination is complete\n        if (current.size() == k) {\n            result.add(new ArrayList<>(current));\n            return;\n        }\n        \n        // Try numbers from start to n\n        for (int i = start; i <= n; i++) {\n            current.add(i);\n            backtrackCombinations(i + 1, n, k, current, result);\n            current.remove(current.size() - 1); // Backtrack\n        }\n    }\n    \n    // Solve N-Queens (LeetCode 51)\n    public static List<List<String>> solveNQueens(int n) {\n        List<List<String>> result = new ArrayList<>();\n        char[][] board = new char[n][n];\n        \n        // Initialize board\n        for (int i = 0; i < n; i++) {\n            Arrays.fill(board[i], '.');\n        }\n        \n        backtrackNQueens(board, 0, result);\n        return result;\n    }\n    \n    private static void backtrackNQueens(char[][] board, int row, List<List<String>> result) {\n        int n = board.length;\n        \n        // Base case: all queens placed\n        if (row == n) {\n            List<String> solution = new ArrayList<>();\n            for (char[] r : board) {\n                solution.add(new String(r));\n            }\n            result.add(solution);\n            return;\n        }\n        \n        // Try placing queen in each column of current row\n        for (int col = 0; col < n; col++) {\n            if (isSafe(board, row, col)) {\n                board[row][col] = 'Q';\n                backtrackNQueens(board, row + 1, result);\n                board[row][col] = '.'; // Backtrack\n            }\n        }\n    }\n    \n    private static boolean isSafe(char[][] board, int row, int col) {\n        int n = board.length;\n        \n        // Check column\n        for (int i = 0; i < row; i++) {\n            if (board[i][col] == 'Q') {\n                return false;\n            }\n        }\n        \n        // Check diagonal (top-left to bottom-right)\n        for (int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) {\n            if (board[i][j] == 'Q') {\n                return false;\n            }\n        }\n        \n        // Check diagonal (top-right to bottom-left)\n        for (int i = row - 1, j = col + 1; i >= 0 && j < n; i--, j++) {\n            if (board[i][j] == 'Q') {\n                return false;\n            }\n        }\n        \n        return true;\n    }\n    \n    // Generate valid parentheses (LeetCode 22)\n    public static List<String> generateParenthesis(int n) {\n        List<String> result = new ArrayList<>();\n        backtrackParentheses(\"\", 0, 0, n, result);\n        return result;\n    }\n    \n    private static void backtrackParentheses(String current, int open, int close, \n                                           int n, List<String> result) {\n        // Base case: string is complete\n        if (current.length() == 2 * n) {\n            result.add(current);\n            return;\n        }\n        \n        // Add opening parenthesis if we haven't used all\n        if (open < n) {\n            backtrackParentheses(current + \"(\", open + 1, close, n, result);\n        }\n        \n        // Add closing parenthesis if it won't make string invalid\n        if (close < open) {\n            backtrackParentheses(current + \")\", open, close + 1, n, result);\n        }\n    }\n    \n    // Word search in 2D board (LeetCode 79)\n    public static boolean exist(char[][] board, String word) {\n        if (board == null || board.length == 0 || board[0].length == 0) {\n            return false;\n        }\n        \n        int rows = board.length;\n        int cols = board[0].length;\n        \n        // Try starting from each cell\n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                if (backtrackWordSearch(board, word, i, j, 0)) {\n                    return true;\n                }\n            }\n        }\n        \n        return false;\n    }\n    \n    private static boolean backtrackWordSearch(char[][] board, String word, \n                                             int row, int col, int index) {\n        // Base case: found the word\n        if (index == word.length()) {\n            return true;\n        }\n        \n        // Check bounds and character match\n        if (row < 0 || row >= board.length || col < 0 || col >= board[0].length ||\n            board[row][col] != word.charAt(index)) {\n            return false;\n        }\n        \n        // Mark cell as visited\n        char temp = board[row][col];\n        board[row][col] = '#';\n        \n        // Explore all 4 directions\n        boolean found = backtrackWordSearch(board, word, row + 1, col, index + 1) ||\n                       backtrackWordSearch(board, word, row - 1, col, index + 1) ||\n                       backtrackWordSearch(board, word, row, col + 1, index + 1) ||\n                       backtrackWordSearch(board, word, row, col - 1, index + 1);\n        \n        // Restore cell value (backtrack)\n        board[row][col] = temp;\n        \n        return found;\n    }\n    \n    // Subset sum problem\n    public static boolean canPartition(int[] nums, int target) {\n        return backtrackSubsetSum(nums, 0, target);\n    }\n    \n    private static boolean backtrackSubsetSum(int[] nums, int index, int target) {\n        // Base case: found target sum\n        if (target == 0) {\n            return true;\n        }\n        \n        // Base case: exceeded target or no more numbers\n        if (target < 0 || index >= nums.length) {\n            return false;\n        }\n        \n        // Include current number or exclude it\n        return backtrackSubsetSum(nums, index + 1, target - nums[index]) ||\n               backtrackSubsetSum(nums, index + 1, target);\n    }\n    \n    // Example usage\n    public static void main(String[] args) {\n        // Test permutations\n        int[] nums = {1, 2, 3};\n        System.out.println(\"Permutations: \" + permute(nums));\n        \n        // Test combinations\n        System.out.println(\"Combinations C(4,2): \" + combine(4, 2));\n        \n        // Test N-Queens\n        List<List<String>> nQueensSolutions = solveNQueens(4);\n        System.out.println(\"4-Queens solutions: \" + nQueensSolutions.size() + \" found\");\n        \n        // Test parentheses generation\n        System.out.println(\"Valid parentheses (n=3): \" + generateParenthesis(3));\n        \n        // Test subset sum\n        int[] subsetNums = {3, 34, 4, 12, 5, 2};\n        int target = 9;\n        System.out.println(\"Subset sum exists for target \" + target + \": \" + \n                          canPartition(subsetNums, target));\n    }\n}",
        "csharp": "// C# Backtracking Implementation\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic class Backtracking\n{\n    // Generate all permutations (LeetCode 46)\n    public static List<List<int>> Permute(int[] nums)\n    {\n        var result = new List<List<int>>();\n        BacktrackPermutations(nums, new List<int>(), result);\n        return result;\n    }\n    \n    private static void BacktrackPermutations(int[] nums, List<int> current, \n                                            List<List<int>> result)\n    {\n        // Base case: permutation is complete\n        if (current.Count == nums.Length)\n        {\n            result.Add(new List<int>(current));\n            return;\n        }\n        \n        // Try each number not yet used\n        foreach (int num in nums)\n        {\n            if (!current.Contains(num))\n            {\n                current.Add(num);\n                BacktrackPermutations(nums, current, result);\n                current.RemoveAt(current.Count - 1); // Backtrack\n            }\n        }\n    }\n    \n    // Generate combinations (LeetCode 77)\n    public static List<List<int>> Combine(int n, int k)\n    {\n        var result = new List<List<int>>();\n        BacktrackCombinations(1, n, k, new List<int>(), result);\n        return result;\n    }\n    \n    private static void BacktrackCombinations(int start, int n, int k, \n                                            List<int> current, List<List<int>> result)\n    {\n        // Base case: combination is complete\n        if (current.Count == k)\n        {\n            result.Add(new List<int>(current));\n            return;\n        }\n        \n        // Try numbers from start to n\n        for (int i = start; i <= n; i++)\n        {\n            current.Add(i);\n            BacktrackCombinations(i + 1, n, k, current, result);\n            current.RemoveAt(current.Count - 1); // Backtrack\n        }\n    }\n    \n    // Solve N-Queens (LeetCode 51)\n    public static List<List<string>> SolveNQueens(int n)\n    {\n        var result = new List<List<string>>();\n        var board = new char[n][];\n        \n        // Initialize board\n        for (int i = 0; i < n; i++)\n        {\n            board[i] = new char[n];\n            Array.Fill(board[i], '.');\n        }\n        \n        BacktrackNQueens(board, 0, result);\n        return result;\n    }\n    \n    private static void BacktrackNQueens(char[][] board, int row, List<List<string>> result)\n    {\n        int n = board.Length;\n        \n        // Base case: all queens placed\n        if (row == n)\n        {\n            var solution = new List<string>();\n            foreach (var r in board)\n            {\n                solution.Add(new string(r));\n            }\n            result.Add(solution);\n            return;\n        }\n        \n        // Try placing queen in each column of current row\n        for (int col = 0; col < n; col++)\n        {\n            if (IsSafe(board, row, col))\n            {\n                board[row][col] = 'Q';\n                BacktrackNQueens(board, row + 1, result);\n                board[row][col] = '.'; // Backtrack\n            }\n        }\n    }\n    \n    private static bool IsSafe(char[][] board, int row, int col)\n    {\n        int n = board.Length;\n        \n        // Check column\n        for (int i = 0; i < row; i++)\n        {\n            if (board[i][col] == 'Q')\n            {\n                return false;\n            }\n        }\n        \n        // Check diagonal (top-left to bottom-right)\n        for (int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--)\n        {\n            if (board[i][j] == 'Q')\n            {\n                return false;\n            }\n        }\n        \n        // Check diagonal (top-right to bottom-left)\n        for (int i = row - 1, j = col + 1; i >= 0 && j < n; i--, j++)\n        {\n            if (board[i][j] == 'Q')\n            {\n                return false;\n            }\n        }\n        \n        return true;\n    }\n    \n    // Generate valid parentheses (LeetCode 22)\n    public static List<string> GenerateParenthesis(int n)\n    {\n        var result = new List<string>();\n        BacktrackParentheses(\"\", 0, 0, n, result);\n        return result;\n    }\n    \n    private static void BacktrackParentheses(string current, int open, int close, \n                                           int n, List<string> result)\n    {\n        // Base case: string is complete\n        if (current.Length == 2 * n)\n        {\n            result.Add(current);\n            return;\n        }\n        \n        // Add opening parenthesis if we haven't used all\n        if (open < n)\n        {\n            BacktrackParentheses(current + \"(\", open + 1, close, n, result);\n        }\n        \n        // Add closing parenthesis if it won't make string invalid\n        if (close < open)\n        {\n            BacktrackParentheses(current + \")\", open, close + 1, n, result);\n        }\n    }\n    \n    // Word search in 2D board (LeetCode 79)\n    public static bool Exist(char[][] board, string word)\n    {\n        if (board == null || board.Length == 0 || board[0].Length == 0)\n        {\n            return false;\n        }\n        \n        int rows = board.Length;\n        int cols = board[0].Length;\n        \n        // Try starting from each cell\n        for (int i = 0; i < rows; i++)\n        {\n            for (int j = 0; j < cols; j++)\n            {\n                if (BacktrackWordSearch(board, word, i, j, 0))\n                {\n                    return true;\n                }\n            }\n        }\n        \n        return false;\n    }\n    \n    private static bool BacktrackWordSearch(char[][] board, string word, \n                                          int row, int col, int index)\n    {\n        // Base case: found the word\n        if (index == word.Length)\n        {\n            return true;\n        }\n        \n        // Check bounds and character match\n        if (row < 0 || row >= board.Length || col < 0 || col >= board[0].Length ||\n            board[row][col] != word[index])\n        {\n            return false;\n        }\n        \n        // Mark cell as visited\n        char temp = board[row][col];\n        board[row][col] = '#';\n        \n        // Explore all 4 directions\n        bool found = BacktrackWordSearch(board, word, row + 1, col, index + 1) ||\n                    BacktrackWordSearch(board, word, row - 1, col, index + 1) ||\n                    BacktrackWordSearch(board, word, row, col + 1, index + 1) ||\n                    BacktrackWordSearch(board, word, row, col - 1, index + 1);\n        \n        // Restore cell value (backtrack)\n        board[row][col] = temp;\n        \n        return found;\n    }\n    \n    // Subset sum problem\n    public static bool CanPartition(int[] nums, int target)\n    {\n        return BacktrackSubsetSum(nums, 0, target);\n    }\n    \n    private static bool BacktrackSubsetSum(int[] nums, int index, int target)\n    {\n        // Base case: found target sum\n        if (target == 0)\n        {\n            return true;\n        }\n        \n        // Base case: exceeded target or no more numbers\n        if (target < 0 || index >= nums.Length)\n        {\n            return false;\n        }\n        \n        // Include current number or exclude it\n        return BacktrackSubsetSum(nums, index + 1, target - nums[index]) ||\n               BacktrackSubsetSum(nums, index + 1, target);\n    }\n    \n    // Example usage\n    static void Main(string[] args)\n    {\n        // Test permutations\n        int[] nums = {1, 2, 3};\n        var permutations = Permute(nums);\n        Console.WriteLine($\"Permutations: [{string.Join(\", \", permutations.Select(p => $\"[{string.Join(\", \", p)}]\"))}]\");\n        \n        // Test combinations\n        var combinations = Combine(4, 2);\n        Console.WriteLine($\"Combinations C(4,2): [{string.Join(\", \", combinations.Select(c => $\"[{string.Join(\", \", c)}]\"))}]\");\n        \n        // Test N-Queens\n        var nQueensSolutions = SolveNQueens(4);\n        Console.WriteLine($\"4-Queens solutions: {nQueensSolutions.Count} found\");\n        \n        // Test parentheses generation\n        var parentheses = GenerateParenthesis(3);\n        Console.WriteLine($\"Valid parentheses (n=3): [{string.Join(\", \", parentheses.Select(p => $\"'{p}'\"))}]\");\n        \n        // Test subset sum\n        int[] subsetNums = {3, 34, 4, 12, 5, 2};\n        int target = 9;\n        Console.WriteLine($\"Subset sum exists for target {target}: {CanPartition(subsetNums, target)}\");\n    }\n}"
      }
    }
  ],
  "categories": {
    "data_structures": ["Array", "Linked List", "Stack", "Queue", "Tree", "Graph", "Hash Table"],
    "algorithms": ["Sorting", "Searching", "Graph", "Dynamic Programming", "Greedy", "Divide & Conquer", "Two Pointers", "Sliding Window", "Backtracking"]
  }
}